(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,218237,903123,850414,179035,115310,63771,887245,858198,110061,e=>{"use strict";let t={path:"/api/v1/apps/:app_id/smart_wallets",method:"GET"};class r{getConfig(){return this._privyInternal.config}async getSmartWalletConfig(){return this._smartWalletConfig||(this._smartWalletConfig=await this._privyInternal.fetch(t,{params:{app_id:this.appId}})),this._smartWalletConfig}get appId(){return this._privyInternal.appId}constructor(e){this._privyInternal=e}}e.s(["default",()=>r],218237);let i={path:"/api/v1/apps/:app_id/cross-app/connections",method:"GET"},s=new TextEncoder,a=new TextDecoder,n=e=>{let t=e;t instanceof Uint8Array&&(t=a.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{var r=t;let e=atob(r),i=new Uint8Array(e.length);for(let t=0;t<e.length;t++)i[t]=e.charCodeAt(t);return i}catch(e){throw TypeError("The input to be decoded is not correctly encoded.")}};e.s(["decode",0,n,"encode",0,e=>(e=>{let t=e;"string"==typeof t&&(t=s.encode(t));let r=[];for(let e=0;e<t.length;e+=32768)r.push(String.fromCharCode.apply(null,t.subarray(e,e+32768)));return btoa(r.join(""))})(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")],903123);class o extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){var t;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,null==(t=Error.captureStackTrace)||t.call(Error,this,this.constructor)}}class c extends o{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class d{static parse(e){try{return new d(e)}catch(e){return null}}get subject(){return this._decoded.sub}get expiration(){return this._decoded.exp}get issuer(){return this._decoded.iss}get audience(){return this._decoded.aud}isExpired(e=0){return Date.now()>=1e3*(this.expiration-e)}constructor(e){this.value=e,this._decoded=function(e){let t,r;if("string"!=typeof e)throw new c("JWTs must use Compact JWS serialization, JWT must be a string");let{1:i,length:s}=e.split(".");if(5===s)throw new c("Only JWTs using Compact JWS serialization can be decoded");if(3!==s)throw new c("Invalid JWT");if(!i)throw new c("JWTs must contain a payload");try{t=n(i)}catch(e){throw new c("Failed to base64url decode the payload")}try{r=JSON.parse(a.decode(t))}catch(e){throw new c("Failed to parse the decoded payload as JSON")}if(!function(e){if("object"!=typeof e||null===e||"[object Object]"!==Object.prototype.toString.call(e))return!1;if(null===Object.getPrototypeOf(e))return!0;let t=e;for(;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}(r))throw new c("Invalid JWT Claims Set");return r}(e)}}e.s(["Token",()=>d],850414);class l{async updateOnCrossAppAuthentication(e,t){let r=t.access_token,i=l.providerAccessTokenStorageKey(e);await this._storage.put(i,r)}async getProviderAccessToken(e){let t=l.providerAccessTokenStorageKey(e),r=await this._storage.get(t);if("string"!=typeof r)return null;try{if(new d(r).isExpired())throw Error("JWT is expired");return r}catch{return await this._storage.del(t),null}}async getCrossAppConnections(){return await this._privyInternal.fetch(i,{params:{app_id:this._privyInternal.appId}})}constructor(e,t){this._privyInternal=e,this._storage=t}}l.providerAccessTokenStorageKey=e=>`privy:cross-app:${e}`,e.s(["default",()=>l],179035);var h=e.i(48210);class p{async revoke(){await this._privyInternal.fetch(h.WalletsRevoke,{})}constructor(e){this._privyInternal=e}}e.s(["default",()=>p],115310);class y extends Error{constructor({error:e,code:t}){super(e),this.error=e,this.code=t}}class _ extends Error{constructor({error:e,code:t}){super(e),this.code=t,this.error=e}}class u extends Error{constructor({error:e,code:t,response:r}){super(e),this.code=t,this.error=e,this.response=r}}e.s(["MoonpayApiError",()=>u,"PrivyApiError",()=>y,"PrivyClientError",()=>_],63771);let v=e=>!!e.id&&"privy-v2"===e.recovery_method;e.s(["isUnifiedWallet",()=>v],887245);class m{async sign({message:e}){return await this.request({method:"sign",params:{message:new TextDecoder("utf8").decode(e)}})}async signTransaction({psbt:e}){return await this.request({method:"signTransaction",params:{psbt:e}})}async request(e){if(v(this._account))throw new _({code:"unsupported_wallet_type",error:"Bitcoin wallet providers are only supported for on-device execution and this app uses TEE execution. Use the useSignRawHash hook from @privy-io/expo/extended-chains to sign over a hash with this wallet. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide"});if(!await this._privyInternal.getAccessTokenInternal())throw new _({error:"Missing access token",code:"attempted_rpc_call_before_logged_in"});return this.handleIFrameRpc(e)}async handleIFrameRpc(e){try{let t=await this._privyInternal.getAccessTokenInternal();if(!t)throw Error("Missing access token. User must be authenticated.");return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:e.method,address:this._account.address}),(await this._proxy.rpcWallet({accessToken:t,request:e,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,hdWalletIndex:this._account.wallet_index,chainType:this._account.chain_type})).response.data}catch(r){console.error(r);let t=r instanceof Error?r.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:e.method,address:this._account.address,error:t}),new _({code:"embedded_wallet_request_error",error:t})}}toJSON(){return`PrivyEmbeddedBitcoinProvider { address: '${this._account.address}', request: [Function] }`}constructor({proxy:e,privyInternal:t,account:r,entropyId:i,entropyIdVerifier:s}){this._proxy=e,this._privyInternal=t,this._account=r,this._entropyId=i,this._entropyIdVerifier=s}}e.s(["EmbeddedBitcoinWalletProvider",()=>m],858198);var g=e.i(654790);async function w({context:e,chainType:t}){return{wallet:await (0,g.create)(e,{request:{chain_type:t,owner_id:void 0}})}}e.s(["walletCreate",()=>w],110061)},664762,e=>{"use strict";var t=e.i(918305),r=e.i(624239),i=e.i(585974);let s=(e,s,n,o)=>{let c=Number(e),d=s.find(e=>e.id===c);if(!d)throw new i.PrivyConnectorError(`Unsupported chainId ${e}`,4901);return(0,t.createPublicClient)({transport:(0,r.http)(a(d,n,o.appId)),chain:d})},a=(e,t,r)=>{let s,a=e.id,n=Number(e.id);if(e.rpcUrls.privyWalletOverride&&e.rpcUrls.privyWalletOverride.http[0])s=e.rpcUrls.privyWalletOverride.http[0];else if(t.rpcUrls&&t.rpcUrls[n])s=t.rpcUrls[n];else if(e.rpcUrls.privy?.http[0]){let t=new URL(e.rpcUrls.privy.http[0]);t.searchParams.append("privyAppId",r),s=t.toString()}else s=e.rpcUrls.public?.http[0]?e.rpcUrls.public.http[0]:e.rpcUrls.default?.http[0];if(!s)throw new i.PrivyConnectorError(`No RPC url found for ${a}`);return s};function n({currentRecoveryMethod:e,upgradeToRecoveryMethod:t}){switch(e){case"privy":case"user-passcode":case"recovery-encryption-key":return!0;case"icloud":case"google-drive":if(e===t)throw Error("Cannot upgrade to the existing cloud platform");return!0;default:throw Error("Unknown recovery method")}}e.s(["getJsonRpcEndpointFromChain",()=>a,"getPublicClient",()=>s,"throwIfInvalidRecoveryUpgradePath",()=>n])},678534,(e,t,r)=>{"use strict";t.exports=function e(t){if("number"==typeof t&&isNaN(t))throw Error("NaN is not allowed");if("number"==typeof t&&!isFinite(t))throw Error("Infinity is not allowed");if(null===t||"object"!=typeof t)return JSON.stringify(t);if(t.toJSON instanceof Function)return e(t.toJSON());if(Array.isArray(t)){let r=t.reduce((t,r,i)=>`${t}${0===i?"":","}${e(void 0===r||"symbol"==typeof r?null:r)}`,"");return`[${r}]`}let r=Object.keys(t).sort().reduce((r,i)=>{if(void 0===t[i]||"symbol"==typeof t[i])return r;let s=0===r.length?"":",";return`${r}${s}${e(i)}:${e(t[i])}`},"");return`{${r}}`}},620724,(e,t,r)=>{e.e,t.exports=function(){"use strict";function e(e){return Number.isInteger(e)&&e>=0}function t(e){this.name="ArgumentError",this.message=e}return function(r,i){if(i=i||{},"function"!=typeof r)throw new t("fetch must be a function");if("object"!=typeof i)throw new t("defaults must be an object");if(void 0!==i.retries&&!e(i.retries))throw new t("retries must be a positive integer");if(void 0!==i.retryDelay&&!e(i.retryDelay)&&"function"!=typeof i.retryDelay)throw new t("retryDelay must be a positive integer or a function returning a positive integer");if(void 0!==i.retryOn&&!Array.isArray(i.retryOn)&&"function"!=typeof i.retryOn)throw new t("retryOn property expects an array or function");return i=Object.assign({retries:3,retryDelay:1e3,retryOn:[]},i),function(s,a){var n=i.retries,o=i.retryDelay,c=i.retryOn;if(a&&void 0!==a.retries)if(e(a.retries))n=a.retries;else throw new t("retries must be a positive integer");if(a&&void 0!==a.retryDelay)if(e(a.retryDelay)||"function"==typeof a.retryDelay)o=a.retryDelay;else throw new t("retryDelay must be a positive integer or a function returning a positive integer");if(a&&a.retryOn)if(Array.isArray(a.retryOn)||"function"==typeof a.retryOn)c=a.retryOn;else throw new t("retryOn property expects an array or function");return new Promise(function(e,t){var i=function(i){r("undefined"!=typeof Request&&s instanceof Request?s.clone():s,a).then(function(r){if(Array.isArray(c)&&-1===c.indexOf(r.status))e(r);else if("function"==typeof c)try{return Promise.resolve(c(i,null,r)).then(function(t){t?d(i,null,r):e(r)}).catch(t)}catch(e){t(e)}else i<n?d(i,null,r):e(r)}).catch(function(e){if("function"==typeof c)try{Promise.resolve(c(i,e,null)).then(function(r){r?d(i,e,null):t(e)}).catch(function(e){t(e)})}catch(e){t(e)}else i<n?d(i,e,null):t(e)})};function d(e,t,r){setTimeout(function(){i(++e)},"function"==typeof o?o(e,t,r):o)}i(0)})}}}()},926485,617303,126190,856298,868620,640692,721018,237446,e=>{"use strict";var t=e.i(218237),r=e.i(179035),i=e.i(115310),s=e.i(606538),a=e.i(891144),n=e.i(63771),o=e.i(858198),c=e.i(585974),d=e.i(110061),l=e.i(664762),h=e.i(887245);async function p(e,t,r,i,s=!1,a,n){let o=s,d=async a=>{if(o){a===+!s?i():r.current?.reject(new c.PrivyIframeError("missing_or_invalid_mfa","MFA verification failed, retry."));let o=await new Promise((e,i)=>{t.current={resolve:e,reject:i},setTimeout(()=>{let e=new c.PrivyIframeError("mfa_timeout","Timed out waiting for MFA code");r.current?.reject(e),i(e)},n)});return await e(o)}return await e()},l=null;for(let e=0;e<a;e++)try{l=await d(e),r.current?.resolve(void 0);break}catch(e){if("missing_or_invalid_mfa"!==e.type)throw r.current?.resolve(void 0),e;o=!0}if(null===l){let e=new c.PrivyIframeError("mfa_verification_max_attempts_reached","Max MFA verification attempts reached");throw r.current?.reject(e),e}return l}let y=(H=0,()=>"id-"+H++),_=(e,t)=>"bigint"==typeof t?t.toString():t,u=async(e,{ms:t,msg:r})=>{let i,s=new Promise((e,s)=>{i=setTimeout(()=>{s(Error(r))},t??15e3)});try{return await Promise.race([e,s])}finally{void 0!==i&&clearTimeout(i)}},v=new class{enqueue(e,t){this.callbacks[e]=t}dequeue(e,t){let r=this.callbacks[t];if(!r)throw Error(`cannot dequeue ${e} event: no event found for id ${t}`);switch(delete this.callbacks[t],e){case"privy:iframe:ready":case"privy:wallets:create":case"privy:user-signer:sign":case"privy:wallets:add":case"privy:wallets:set-recovery":case"privy:wallets:connect":case"privy:wallets:recover":case"privy:wallets:rpc":case"privy:wallet:create":case"privy:wallet:connect":case"privy:wallet:recover":case"privy:wallet:rpc":case"privy:solana-wallet:create":case"privy:solana-wallet:create-additional":case"privy:solana-wallet:connect":case"privy:solana-wallet:recover":case"privy:solana-wallet:rpc":case"privy:delegated-actions:consent":case"privy:mfa:verify":case"privy:mfa:init-enrollment":case"privy:mfa:submit-enrollment":case"privy:mfa:unenroll":case"privy:mfa:clear":return r;default:throw Error(`invalid wallet event type ${e}`)}}constructor(){this.callbacks={}}};class m{invokeWithMfa(e,t){return u(p(r=>u(this.waitForReady().then(()=>e(r)),{msg:t.timeoutMsg,ms:t.timeoutMs}),this.mfa.rootPromise,this.mfa.submitPromise,()=>this.mfa.emit("mfaRequired"),t.mfaAlwaysRequired??!1,4,3e5),{msg:"Operation reached timeout: MFA verification",ms:126e4})}reload(){return this.ready=!1,this._embeddedWalletMessagePoster.reload()}ping(e=15e3){return u(this.invoke("privy:iframe:ready",{}),{msg:"Ping reached timeout",ms:e})}create(e){return u(this.waitForReady().then(()=>this.invoke("privy:wallet:create",e)),{msg:"Operation reached timeout: create"})}rpc(e){return this.invokeWithMfa(t=>this.invoke("privy:wallet:rpc",{...t,...e}),{timeoutMsg:"Operation reached timeout: rpc"})}createSolana(e){return this.invokeWithMfa(t=>this.invoke("privy:solana-wallet:create",{...t,...e}),{timeoutMsg:"Operation reached timeout: create",timeoutMs:6e4})}createAdditionalSolana(e){return u(this.waitForReady().then(()=>this.invoke("privy:solana-wallet:create-additional",e)),{msg:"Operation reached timeout: create"})}solanaRpc(e){return this.invokeWithMfa(t=>this.invoke("privy:solana-wallet:rpc",{...t,...e}),{timeoutMsg:"Operation reached timeout: solana-rpc"})}delegateWallets(e){return this.invokeWithMfa(t=>this.invoke("privy:delegated-actions:consent",{...t,...e}),{timeoutMsg:"Operation reached timeout: delegated-actions:consent"})}verifyMfa(e){return this.invokeWithMfa(t=>this.invoke("privy:mfa:verify",{...t,...e}),{timeoutMsg:"Operation reached timeout: mfa:verify",mfaAlwaysRequired:!0})}initEnrollMfa(e){return this.invokeWithMfa(t=>this.invoke("privy:mfa:init-enrollment",{...t,...e}),{timeoutMsg:"Operation reached timeout: mfa:init-enrollment"})}submitEnrollMfa(e){return this.invokeWithMfa(t=>this.invoke("privy:mfa:submit-enrollment",{...t,...e}),{timeoutMsg:"Operation reached timeout: mfa:submit-enrollment"})}unenrollMfa(e){return this.invokeWithMfa(t=>this.invoke("privy:mfa:unenroll",{...t,...e}),{timeoutMsg:"Operation reached timeout: mfa:unenroll",mfaAlwaysRequired:!0})}clearMfa(e){return u(this.waitForReady().then(()=>this.invoke("privy:mfa:clear",e)),{msg:"Operation reached timeout: mfa:clear"})}createWallet(e){return this.invokeWithMfa(t=>this.invoke("privy:wallets:create",{...t,...e}),{timeoutMsg:"Operation reached timeout: create",timeoutMs:6e4})}signWithUserSigner(e){return this.invokeWithMfa(t=>this.invoke("privy:user-signer:sign",{...t,...e}),{timeoutMsg:"Operation reached timeout: user-signer:sign"})}addWallet(e){return u(this.waitForReady().then(()=>this.invoke("privy:wallets:add",e)),{msg:"Operation reached timeout: wallets:add"})}setRecovery(e){return this.invokeWithMfa(t=>this.invoke("privy:wallets:set-recovery",{...t,...e}),{timeoutMsg:"Operation reached timeout: wallets:set-recovery",timeoutMs:6e4})}connect(e){return u(this.waitForReady().then(()=>this.invoke("privy:wallets:connect",e)),{msg:"Operation reached timeout: wallets:connect"})}recover(e){return this.invokeWithMfa(t=>this.invoke("privy:wallets:recover",{...t,...e}),{timeoutMsg:"Operation reached timeout: wallets:recover",timeoutMs:6e4})}rpcWallet(e){return this.invokeWithMfa(t=>this.invoke("privy:wallets:rpc",{...t,...e}),{timeoutMsg:"Operation reached timeout: wallets:rpc"})}handleEmbeddedWalletMessages(e){if(!e.event.startsWith("privy:"))return void console.warn(`Unsupported event type: ${e.event}`);let{reject:t,resolve:r}=v.dequeue(e.event,e.id);return void 0!==e.error?t(new c.PrivyIframeError(e.error.type,e.error.message)):r(e.data)}waitForReady(){return this.ready?Promise.resolve():new Promise(async(e,t)=>{for(;!this.ready;)this.invoke("privy:iframe:ready",{}).then(()=>{this.ready=!0,e()}).catch(t),await new Promise(e=>{setTimeout(()=>{e()},150)})})}invoke(e,t){let r=`${e}${JSON.stringify(t,_)}`;if("privy:wallet:create"===e||"privy:solana-wallet:create"===e){let e=this.cache.get(r);if(e)return e}let i=new Promise((r,i)=>{let s=y();v.enqueue(s,{resolve:r,reject:i}),this._embeddedWalletMessagePoster.postMessage(JSON.stringify({id:s,event:e,data:t}),"*")}).finally(()=>{this.cache.delete(r)});return this.cache.set(r,i),i}constructor(e,t){this.ready=!1,this.cache=new Map,this._embeddedWalletMessagePoster=e,this.mfa=t}}var g=e.i(737281),w=e.i(404330),f=e.i(661126);let I={0:"legacy",1:"eip2930",2:"eip1559",3:"eip4844",4:"eip7702"},k={legacy:0,eip2930:1,eip1559:2,eip4844:3,eip7702:4},b=e=>void 0!==e?BigInt(e):void 0;function T(e){let t,{type:r=2,...i}="string"==typeof e?JSON.parse(e):e;i.accessList&&Array.isArray(i.accessList)?t=i.accessList.map(e=>Array.isArray(e)?{address:e[0],storageKeys:e[1]}:e):i.accessList&&(t=Object.entries(i.accessList).map(e=>({address:e[0],storageKeys:e[1]})));let s=Number(i.chainId??1),a=(0,f.isHex)(i.data)?i.data:i.data?(0,w.toHex)(Uint8Array.from(i.data)):void 0,n=i.nonce?Number(i.nonce):void 0,o={chainId:s,data:a,nonce:n,value:b(i.value),gas:b(i.gas??i.gasLimit)},c=Number(r);if(0===c)return{...i,type:I[c],...o,gasPrice:b(i.gasPrice),accessList:void 0,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(1===c)return{...i,type:I[c],...o,gasPrice:b(i.gasPrice),accessList:t,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(2===c)return{...i,type:I[c],...o,nonce:n,accessList:t,maxFeePerGas:b(i.maxFeePerGas),maxPriorityFeePerGas:b(i.maxPriorityFeePerGas),gasPrice:void 0,maxFeePerBlobGas:void 0};throw Error(`Unsupported transaction type: ${r}`)}e.s(["STRING_TO_NUMBER_TXN_TYPE",()=>k,"toViemTransactionSerializable",()=>T],617303);var E=e.i(389978);let A=e=>E.Buffer.from(e,"utf8"),S=e=>`0x${e.toString("hex")}`;var P=e.i(48210),R=e.i(678534);async function O(e,t){let r=(0,R.default)(t);if(void 0===r)throw new n.PrivyClientError({error:"Failed to prepare the payload for signing",code:"invalid_input"});let i=E.Buffer.from(r).toString("base64"),{signature:s}=await e({message:i});return{signature:s}}async function C(e,t,{wallet_id:r,...i}){let s={version:1,url:e.getCompiledPath(P.WalletRpc,{params:{wallet_id:r}}),method:P.WalletRpc.method,headers:{"privy-app-id":e.app.appId},body:{...i}},{signature:a}=await O(t,s);return await e.fetchPrivyRoute(P.WalletRpc,{body:i,params:{wallet_id:r},headers:{"privy-authorization-signature":a}})}function x(e){if("number"==typeof e||"bigint"==typeof e)return`0x${BigInt(e).toString(16)}`;if("string"==typeof e)return/^0x[0-9a-fA-F]*$/.test(e)?e:S(A(e))}async function U({context:e,account:t,rpcRequest:r}){switch(r.chainType){case"ethereum":return async function({context:e,account:t,rpcRequest:r}){var i;switch(r.method){case"personal_sign":{let[i]=r.params,s=await C(e,e.signRequest,{chain_type:"ethereum",method:"personal_sign",wallet_id:t.id,params:i.startsWith("0x")?{message:i.slice(2),encoding:"hex"}:{message:i,encoding:"utf-8"}});if("personal_sign"!==s.method)throw Error("Unable to sign message");return{data:s.data.signature}}case"eth_signTransaction":{let[i]=r.params,s=await C(e,e.signRequest,{chain_type:"ethereum",method:"eth_signTransaction",wallet_id:t.id,params:{transaction:{from:i.from,to:i.to??void 0,nonce:x(i.nonce),chain_id:x(i.chainId),data:function(e){if(void 0!==e)return"string"==typeof e?/^0x[0-9a-fA-F]*$/.test(e)?e:S(A(e)):S(E.Buffer.from(Uint8Array.from(e)))}(i.data),value:x(i.value),type:i.type,gas_limit:x(i.gasLimit),gas_price:x(i.gasPrice),max_fee_per_gas:x(i.maxFeePerGas),max_priority_fee_per_gas:x(i.maxPriorityFeePerGas)}}});if("eth_signTransaction"!==s.method)throw Error("Unable to sign transaction");return{data:s.data.signed_transaction}}case"eth_signTypedData_v4":{let[,s]=r.params,a=await C(e,e.signRequest,{chain_type:"ethereum",method:r.method,wallet_id:t.id,params:{typed_data:("string"==typeof(i=s)&&(i=JSON.parse(i)),{types:i.types,primary_type:String(i.primaryType),domain:i.domain,message:i.message})}});if("eth_signTypedData_v4"!==a.method)throw Error("Unable to sign typed data");return{data:a.data.signature}}case"eth_sign":{let[,i]=r.params,s=await C(e,e.signRequest,{chain_type:"ethereum",method:"secp256k1_sign",wallet_id:t.id,params:{hash:/^0x[0-9a-fA-F]*$/.test(i)?i:S(A(i))}});if("secp256k1_sign"!==s.method)throw Error("Unable to sign message");return{data:s.data.signature}}case"secp256k1_sign":{let[i]=r.params,s=await C(e,e.signRequest,{chain_type:"ethereum",method:"secp256k1_sign",wallet_id:t.id,params:{hash:/^0x[0-9a-fA-F]*$/.test(i)?i:S(A(i))}});if("secp256k1_sign"!==s.method)throw Error("Unable to sign message");return{data:s.data.signature}}case"csw_signUserOperation":case"eth_sendTransaction":case"eth_populateTransactionRequest":throw Error(`This wallet does not support the method: ${r.method}`)}}({context:e,account:t,rpcRequest:r.request});case"solana":return async function({context:e,account:t,rpcRequest:r}){if("signMessage"===r.method){let{message:i}=r.params,s=await C(e,e.signRequest,{chain_type:"solana",method:"signMessage",wallet_id:t.id,params:{message:i,encoding:"base64"}});if("signMessage"!==s.method)throw Error("Unable to sign message");return{data:s.data.signature}}}({context:e,account:t,rpcRequest:r.request})}}e.s(["generateAuthorizationSignature",()=>O],126190),e.s(["rpc",()=>C],856298);let N=new Set(["eth_sign","personal_sign","eth_signTypedData_v4","csw_signUserOperation","secp256k1_sign"]);class M extends g.default{async request(e){if(N.has(e.method))return this.handleIFrameRpc(e);switch(e.method){case"eth_accounts":case"eth_requestAccounts":return this._account.address?[this._account.address]:[];case"eth_chainId":return`0x${this._chainId.toString(16)}`;case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(e);case"eth_estimateGas":return this.handleEstimateGas(e);case"eth_signTransaction":{let t=e.params?.[0];return this.handleSignTransaction(t)}case"eth_sendTransaction":{let t=e.params?.[0];return this.handleSendTransaction(t)}case"eth_populateTransactionRequest":{let t=e.params?.[0];return this.handlePopulateTransaction(t)}default:return this.handleJsonRpc(e)}}ensureChainId(e){let t={chainId:this._chainId,...e};return this.internalSwitchEthereumChain(t.chainId),t}internalSwitchEthereumChain(e){e&&Number(e)!==this._chainId&&(this._chainId=Number(e),this._client=(0,l.getPublicClient)(this._chainId,this._chains,{rpcUrls:[]},{appId:this._privyInternal.appId}),this.emit("chainChanged",e))}async handlePopulateTransaction(e){let t=this.ensureChainId(e),r=T(t),{type:i,...s}=await this._client.prepareTransactionRequest({account:t.from??this._account.address,...r});return{...s,type:k[i]}}async handleSignTransaction(e){let t={...e};for(let e of Object.keys(t)){let r=t[e];r&&"bigint"==typeof r&&(t[e]=(0,w.toHex)(r))}return await this.handleIFrameRpc({method:"eth_signTransaction",params:[t]})}async handleSendTransaction(e){let t=await this.handlePopulateTransaction(e),r=await this.handleSignTransaction(t);return await this.handleJsonRpc({method:"eth_sendRawTransaction",params:[r]})}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_estimateGas");let t=e.params?.[0],r=this.ensureChainId(t),i=T(r);return await this._client.estimateGas({account:r.from??this._account.address,...i})}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new c.EmbeddedProviderError(`Invalid params for ${e.method}`,4200);if("string"==typeof e.params[0])t=e.params[0];else{if(!("chainId"in e.params[0])||"string"!=typeof e.params[0].chainId)throw new c.EmbeddedProviderError(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.internalSwitchEthereumChain(t)}async handleIFrameRpc(e){try{let t=await this._privyInternal.getAccessTokenInternal();if(!t)throw Error("Missing privy token. User must be logged in");this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:e.method,address:this._account.address});let r=this._account;if((0,h.isUnifiedWallet)(r)){let{data:i}=await U({context:{app:this._appApi,fetchPrivyRoute:(...e)=>this._privyInternal.fetch(...e),getCompiledPath:(...e)=>this._privyInternal.getPath(...e),signRequest:({message:e})=>this._walletProxy.signWithUserSigner({accessToken:t,message:e})},account:r,rpcRequest:{chainType:"ethereum",request:e}});return i}try{await this._walletProxy.connect({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:t})}catch(r){let e=(0,c.errorIndicatesRecoveryIsNeeded)(r);if(e&&"privy"===this._account.recovery_method)await this._walletProxy.recover({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:t});else{if(!e||!this._onNeedsRecovery)throw r;{let e;await new Promise(async(t,r)=>{e=setTimeout(()=>r(new n.PrivyClientError({code:"embedded_wallet_recovery_error",error:"User-owned recovery timed out"})),12e4),await this._onNeedsRecovery?.({recoveryMethod:this._account.recovery_method,onRecovered:()=>t(!0)})}).finally(()=>clearTimeout(e))}}}return(await this._walletProxy.rpcWallet({accessToken:t,request:e,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,hdWalletIndex:this._account.wallet_index,chainType:"ethereum"})).response.data}catch(r){console.error(r);let t=r instanceof Error?r.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:e.method,address:this._account.address,error:t}),new n.PrivyClientError({code:"embedded_wallet_request_error",error:t})}}async handleJsonRpc(e){return this._client.request(e)}toJSON(){return`PrivyEIP1193Provider { address: '${this._account.address}', chainId: ${this._chainId}, request: [Function] }`}constructor({walletProxy:e,privyInternal:t,account:r,entropyId:i,entropyIdVerifier:s,chains:a,onNeedsRecovery:n,chainId:o=a[0].id,appApi:c}){super(),this._walletProxy=e,this._privyInternal=t,this._account=r,this._entropyId=i,this._entropyIdVerifier=s,this._chainId=o,this._chains=a,this._onNeedsRecovery=n,this._client=(0,l.getPublicClient)(o,a,{rpcUrls:[]},{appId:c.appId}),this._appApi=c}}function W(e){return"version"in e}function D(e,t){let r=(W(e)?e.message:e.compileMessage()).staticAccountKeys.find(e=>e.toBase58()===t);if(!r)throw Error(`Transaction does not contain public key ${t}`);return r}class L{async request(e){if(!await this._privyInternal.getAccessTokenInternal())throw new n.PrivyClientError({error:"Missing access token",code:"attempted_rpc_call_before_logged_in"});switch(e.method){case"signAndSendTransaction":return await this.handleSignAndSendTransaction(e);case"signTransaction":return await this.handleSignTransaction(e);default:return await this.handleIFrameRpc(e)}}get _publicKey(){return this._account.address}async connectAndRecover(e){if("privy-v2"!==this._account.recovery_method)try{await this._proxy.connect({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:e})}catch(r){let t=(0,c.errorIndicatesRecoveryIsNeeded)(r);if(t&&"privy"===this._account.recovery_method)await this._proxy.recover({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:e});else{if(!t||!this._onNeedsRecovery)throw r;{let e;await new Promise(async(t,r)=>{e=setTimeout(()=>r(new n.PrivyClientError({code:"embedded_wallet_recovery_error",error:"User-owned recovery timed out"})),12e4),await this._onNeedsRecovery?.({recoveryMethod:this._account.recovery_method,onRecovered:()=>t(!0)})}).finally(()=>clearTimeout(e))}}}}async signMessageRpc(e,t){let r=this._account;if(!(0,h.isUnifiedWallet)(r))return(await this._proxy.rpcWallet({accessToken:t,request:e,chainType:"solana",hdWalletIndex:this._account.wallet_index,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier})).response.data;{let{data:i}=await U({context:{app:this._app,fetchPrivyRoute:(...e)=>this._privyInternal.fetch(...e),getCompiledPath:(...e)=>this._privyInternal.getPath(...e),signRequest:({message:e})=>this._proxy.signWithUserSigner({accessToken:t,message:e})},account:r,rpcRequest:{chainType:"solana",request:e}});return{signature:i}}}async handleIFrameRpc(e){try{let t=await this._privyInternal.getAccessTokenInternal();if(!t)throw Error("Missing privy token. User must be logged in");return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:e.method,address:this._account.address}),await this.connectAndRecover(t),await this.signMessageRpc(e,t)}catch(r){console.error(r);let t=r instanceof Error?r.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:e.method,address:this._account.address,error:t}),new n.PrivyClientError({code:"embedded_wallet_request_error",error:t})}}async handleSignAndSendTransaction(e){try{let t=await this._privyInternal.getAccessTokenInternal();if(!t)throw Error("Missing privy token. User must be logged in");this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:e.method,address:this._account.address}),await this.connectAndRecover(t);let{transaction:r,connection:i,options:s}=e.params,a=D(r,this._account.address),n=W(r)?E.Buffer.from(r.message.serialize()):r.serializeMessage(),{signature:o}=await this.signMessageRpc({method:"signMessage",params:{message:n.toString("base64")}},t);return r.addSignature(a,E.Buffer.from(o,"base64")),{signature:await i.sendRawTransaction(r.serialize(),s)}}catch(r){console.error(r);let t=r instanceof Error?r.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:e.method,address:this._account.address,error:t}),new n.PrivyClientError({code:"embedded_wallet_request_error",error:t})}}async handleSignTransaction(e){try{let t=await this._privyInternal.getAccessTokenInternal();if(!t)throw Error("Missing privy token. User must be logged in");this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:e.method,address:this._account.address}),await this.connectAndRecover(t);let{transaction:r}=e.params,i=D(r,this._account.address),s=W(r)?E.Buffer.from(r.message.serialize()):r.serializeMessage(),{signature:a}=await this.signMessageRpc({method:"signMessage",params:{message:s.toString("base64")}},t);return r.addSignature(i,E.Buffer.from(a,"base64")),{signedTransaction:r}}catch(r){console.error(r);let t=r instanceof Error?r.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:e.method,address:this._account.wallet_index,error:t}),new n.PrivyClientError({code:"embedded_wallet_request_error",error:t})}}toJSON(){return`PrivyEmbeddedSolanaProvider { address: '${this._account.address}', request: [Function] }`}constructor({proxy:e,privyInternal:t,account:r,entropyId:i,entropyIdVerifier:s,onNeedsRecovery:a,app:n}){this._proxy=e,this._privyInternal=t,this._account=r,this._entropyId=i,this._entropyIdVerifier=s,this._onNeedsRecovery=a,this._app=n}}class V{setMessagePoster(e){this._proxy=new m(e,this._mfaPromises),this._mfa.setProxy(this._proxy)}async signWithUserSigner(e){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");let t=await this._privyInternal.getAccessTokenInternal();if(!t)throw new n.PrivyClientError({error:"User must be logged in to sign a message with the user signer",code:"user_signer_sign_error"});let{signature:r}=await this._proxy.signWithUserSigner({accessToken:t,message:e.message});return{signature:r}}async add(e){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");if("user-controlled-server-wallets-only"===this._privyInternal.config?.embedded_wallet_config.mode)await (0,d.walletCreate)({context:{app:this._appApi,fetchPrivyRoute:(...e)=>this._privyInternal.fetch(...e),getCompiledPath:(...e)=>this._privyInternal.getPath(...e)},chainType:e.chainType});else{let t=await this._privyInternal.getAccessTokenInternal();if(!t)throw new n.PrivyClientError({error:"User must be logged in to create an embedded wallet",code:"embedded_wallet_creation_error"});await this._proxy.addWallet({accessToken:t,...e})}let{user:t}=await this._privyInternal.refreshSession();return{user:t}}async getBitcoinProvider({wallet:e,entropyId:t,entropyIdVerifier:r,recoveryPassword:i,recoveryAccessToken:s,recoverySecretOverride:a}){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");if(!await this._privyInternal.getAccessTokenInternal())throw Error("User must be logged in to create an embedded wallet");return(0,h.isUnifiedWallet)(e)||await this._load({entropyId:t,entropyIdVerifier:r,wallet:e,recoveryPassword:i,recoveryAccessToken:s,recoverySecretOverride:a}),new o.EmbeddedBitcoinWalletProvider({account:e,privyInternal:this._privyInternal,proxy:this._proxy,entropyId:t,entropyIdVerifier:r})}async create({password:e,recoveryMethod:t,recoveryToken:r,recoveryKey:i,recoverySecretOverride:s,iCloudRecordNameOverride:a,solanaAccount:o,skipCallbacks:c}){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");if("user-controlled-server-wallets-only"===this._privyInternal.config?.embedded_wallet_config.mode){if(t&&!t.startsWith("privy"))throw new n.PrivyClientError({error:"User-controlled server wallets do not support custom recovery methods",code:"embedded_wallet_creation_error"});await (0,d.walletCreate)({context:{app:this._appApi,fetchPrivyRoute:(...e)=>this._privyInternal.fetch(...e),getCompiledPath:(...e)=>this._privyInternal.getPath(...e)},chainType:"ethereum"})}else{let n;if(n=t||(e?"user-passcode":"privy"),e&&"string"!=typeof e)throw Error("Invalid recovery password, must be a string");if("privy"===n&&this._privyInternal.config?.embedded_wallet_config.require_user_password_on_create)throw Error("Password not provided yet is required by App configuration");let c=await this._privyInternal.getAccessTokenInternal();if(!c)throw Error("User must be logged in to create an embedded wallet");let{address:d}=await this._proxy.create({accessToken:c,recoveryMethod:n,recoveryKey:i,recoveryPassword:e,recoveryAccessToken:r,recoverySecretOverride:s,iCloudRecordNameOverride:a,solanaAddress:o?.address});if(!d)throw Error("Failed to create wallet")}return await this._privyInternal.refreshSession(c)}async createSolana(e){if(!this._proxy)throw new n.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_creation_error"});if("user-controlled-server-wallets-only"===this._privyInternal.config?.embedded_wallet_config.mode)await (0,d.walletCreate)({context:{app:this._appApi,fetchPrivyRoute:(...e)=>this._privyInternal.fetch(...e),getCompiledPath:(...e)=>this._privyInternal.getPath(...e)},chainType:"solana"});else{let t=await this._privyInternal.getAccessTokenInternal();if(!t)throw new n.PrivyClientError({error:"User must be logged in to create an embedded wallet",code:"embedded_wallet_creation_error"});e?.ethereumAccount&&await this.getProvider(e.ethereumAccount);let{publicKey:r}=await this._proxy.createSolana({accessToken:t,ethereumAddress:e?.ethereumAccount?.address});if(!r)throw new n.PrivyClientError({error:"Failed to create wallet",code:"embedded_wallet_creation_error"})}return await this._privyInternal.refreshSession()}async delegateWallets({delegatedWallets:e,rootWallet:t}){if(!this._proxy)throw new n.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_creation_error"});let r=await this._privyInternal.getAccessTokenInternal();if(!r)throw new n.PrivyClientError({error:"User must be logged in to create an embedded wallet",code:"embedded_wallet_creation_error"});await this._proxy.delegateWallets({accessToken:r,delegatedWallets:e,rootWallet:t})}async getProvider(e,t,r,i,s){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");return(0,h.isUnifiedWallet)(e)||await this._load({wallet:e,entropyId:e.address,entropyIdVerifier:"ethereum-address-verifier",recoveryPassword:t,recoveryKey:s,recoveryAccessToken:r,recoverySecretOverride:i}),new M({account:e,entropyId:e.address,entropyIdVerifier:"ethereum-address-verifier",privyInternal:this._privyInternal,chains:this._chains,walletProxy:this._proxy,appApi:this._appApi})}async getEthereumProvider({wallet:e,entropyId:t,entropyIdVerifier:r,recoveryPassword:i,recoveryAccessToken:s,recoverySecretOverride:a,recoveryKey:n,onNeedsRecovery:o}){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");if(!await this._privyInternal.getAccessTokenInternal())throw Error("User must be logged in to create an embedded wallet");return(0,h.isUnifiedWallet)(e)||(!o||i||s||a||n)&&await this._load({entropyId:t,entropyIdVerifier:r,wallet:e,recoveryPassword:i,recoveryAccessToken:s,recoverySecretOverride:a,recoveryKey:n}),new M({account:e,entropyId:t,entropyIdVerifier:"ethereum-address-verifier",privyInternal:this._privyInternal,chains:this._chains,walletProxy:this._proxy,onNeedsRecovery:o,appApi:this._appApi})}async getSolanaProvider(e,t,r,i,s,a,o){if(!this._proxy)throw new n.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_webview_not_loaded"});return(0,h.isUnifiedWallet)(e)||(!o||i||s||a)&&await this._load({wallet:e,entropyId:t,entropyIdVerifier:r,recoveryPassword:i,recoveryAccessToken:s,recoverySecretOverride:a}),new L({account:e,privyInternal:this._privyInternal,proxy:this._proxy,entropyId:t,entropyIdVerifier:r,onNeedsRecovery:o,app:this._appApi})}async setRecovery(e){let{wallet:t,...r}=e;if(!this._proxy)throw Error("Embedded wallet proxy not initialized");if((0,h.isUnifiedWallet)(t))throw new n.PrivyClientError({error:"This wallet does not support setting recovery methods",code:"unsupported_recovery_method"});(0,l.throwIfInvalidRecoveryUpgradePath)({currentRecoveryMethod:t.recovery_method,upgradeToRecoveryMethod:"icloud-native"===r.recoveryMethod?"icloud":r.recoveryMethod}),await this._load("solana"===t.chain_type?{wallet:t,entropyId:t.address,entropyIdVerifier:"solana-address-verifier"}:{wallet:t,entropyId:t.address,entropyIdVerifier:"ethereum-address-verifier"});let i=await this._privyInternal.getAccessTokenInternal();if(!i)throw Error("User must be logged in to interact with embedded wallets");let s=t.recovery_method;this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_set_recovery_started",{address:t.address,target_recovery_method:r.recoveryMethod,existing_recovery_method:s});try{let e;if("user-passcode"===r.recoveryMethod)e={recoveryMethod:"user-passcode",recoveryPassword:r.password};else if("google-drive"===r.recoveryMethod)e={recoveryMethod:"google-drive",recoveryAccessToken:r.recoveryAccessToken};else if("icloud"===r.recoveryMethod)e={recoveryMethod:"icloud",recoveryAccessToken:r.recoveryAccessToken};else if("icloud-native"===r.recoveryMethod)e={recoveryMethod:"icloud-native",iCloudRecordNameOverride:r.iCloudRecordNameOverride,recoverySecretOverride:r.recoverySecretOverride};else if("recovery-encryption-key"===r.recoveryMethod)e={recoveryMethod:"recovery-encryption-key",recoveryKey:r.recoveryKey};else{if("privy"!==r.recoveryMethod)throw Error(`Unknown recovery method: ${r.recoveryMethod}`);e={recoveryMethod:"privy"}}await this._proxy.setRecovery({accessToken:i,entropyId:t.address,entropyIdVerifier:"solana"===t.chain_type?"solana-address-verifier":"ethereum-address-verifier",...e}),this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_set_recovery_completed",{address:t.address,target_recovery_method:r.recoveryMethod,existing_recovery_method:s});let{user:a}=await this._privyInternal.refreshSession();return{user:a,provider:"ethereum"!==t.chain_type?null:new M({account:t,entropyId:t.address,entropyIdVerifier:"ethereum-address-verifier",privyInternal:this._privyInternal,chains:this._chains,walletProxy:this._proxy,appApi:this._appApi})}}catch(e){throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_set_recovery_failed",{address:t.address,recovery_method:t.recovery_method,error:e instanceof Error?e.message:"Unable to recover wallet"}),e}}getURL(){let e=new URL(`${this._privyInternal.baseUrl}/apps/${this._privyInternal.appId}/embedded-wallets`);return this._privyInternal.caid&&e.searchParams.append("caid",this._privyInternal.caid),this._privyInternal.appClientId&&e.searchParams.append("client_id",this._privyInternal.appClientId),e.href}get chains(){return this._chains}onMessage(e){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");return this._proxy.handleEmbeddedWalletMessages(e)}reload(){this._proxy?this._proxy.reload():console.warn("Attempted to reload proxy before initialized")}async ping(e){try{if(!this._proxy)throw Error("Embedded wallet proxy not initialized");return await this._proxy.ping(e),!0}catch(e){return console.error(e),!1}}async _load({entropyId:e,entropyIdVerifier:t,wallet:r,recoveryPassword:i,recoveryKey:s,recoveryAccessToken:a,recoverySecretOverride:n}){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");let o=await this._privyInternal.getAccessTokenInternal();if(!o)throw Error("User must be logged in to interact with embedded wallets");try{return await this._proxy.connect({accessToken:o,entropyId:e,entropyIdVerifier:t}),e}catch(d){if((0,c.errorIndicatesRecoveryIsNeeded)(d))try{if("privy"===r.recovery_method){this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started",{address:r.address,recovery_method:r.recovery_method});let i=await this._proxy.recover({accessToken:o,entropyId:e,entropyIdVerifier:t});return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed",{address:r.address,recovery_method:r.recovery_method}),i.entropyId}if("user-passcode"===r.recovery_method&&i){this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started",{address:r.address,recovery_method:r.recovery_method});let s=await this._proxy.recover({accessToken:o,recoveryPassword:i,entropyId:e,entropyIdVerifier:t});return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed",{address:r.address,recovery_method:r.recovery_method}),s.entropyId}if(["google-drive","icloud"].includes(r.recovery_method)&&a){this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started",{address:r.address,recovery_method:r.recovery_method});let i=await this._proxy.recover({accessToken:o,recoveryAccessToken:a,entropyId:e,entropyIdVerifier:t});return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed",{address:r.address,recovery_method:r.recovery_method}),i.entropyId}if("icloud"===r.recovery_method&&n){this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started",{address:r.address,recovery_method:"icloud-native"});let i=await this._proxy.recover({accessToken:o,recoverySecretOverride:n,entropyId:e,entropyIdVerifier:t});return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed",{address:r.address,recovery_method:"icloud-native"}),i.entropyId}if("recovery-encryption-key"===r.recovery_method&&s){this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started",{address:r.address,recovery_method:r.recovery_method});let i=await this._proxy.recover({accessToken:o,recoveryKey:s,entropyId:e,entropyIdVerifier:t});return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed",{address:r.address,recovery_method:r.recovery_method}),i.entropyId}}catch(t){throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_failed",{address:r.address,recovery_method:r.recovery_method,error:t instanceof Error?t.message:`Unable to recover wallet: ${e}`}),t}throw d}}constructor(e,t,r,i,n,o){if(this._chains=Array.from(s.DEFAULT_SUPPORTED_CHAINS),this._privyInternal=e,t&&(this._proxy=new m(t,n),i.setProxy(this._proxy)),r){let e=(0,a.dedupeSupportedChains)(r);this._chains=e}this._mfa=i,this._mfaPromises=n,this._appApi=o}}var q=g;class $ extends q.default{constructor(){super(),this.rootPromise={current:null},this.submitPromise={current:null}}}var F=e.i(620724),G=new Uint8Array(16);let z=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;for(var j=[],K=0;K<256;++K)j.push((K+256).toString(16).substr(1));let B=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=(j[e[t+0]]+j[e[t+1]]+j[e[t+2]]+j[e[t+3]]+"-"+j[e[t+4]]+j[e[t+5]]+"-"+j[e[t+6]]+j[e[t+7]]+"-"+j[e[t+8]]+j[e[t+9]]+"-"+j[e[t+10]]+j[e[t+11]]+j[e[t+12]]+j[e[t+13]]+j[e[t+14]]+j[e[t+15]]).toLowerCase();if(!("string"==typeof r&&z.test(r)))throw TypeError("Stringified UUID is invalid");return r},J=function(e,t,r){var i=(e=e||{}).random||(e.rng||function(){if(!Y&&!(Y="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return Y(G)})();if(i[6]=15&i[6]|64,i[8]=63&i[8]|128,t){r=r||0;for(var s=0;s<16;++s)t[r+s]=i[s];return t}return B(i)};e.s(["v4",0,J],868620);var H,Y,X,Q=((X={}).OAUTH_ACCOUNT_SUSPENDED="oauth_account_suspended",X.MISSING_OR_INVALID_PRIVY_APP_ID="missing_or_invalid_privy_app_id",X.MISSING_OR_INVALID_PRIVY_CLIENT_ID="missing_or_invalid_privy_client_id",X.MISSING_OR_INVALID_PRIVY_ACCOUNT_ID="missing_or_invalid_privy_account_id",X.MISSING_OR_INVALID_TOKEN="missing_or_invalid_token",X.MISSING_MFA_ENROLLMENT="missing_mfa_enrollment",X.MISSING_OR_INVALID_MFA="missing_or_invalid_mfa",X.EXPIRED_OR_INVALID_MFA_TOKEN="expired_or_invalid_mfa_token",X.INVALID_DATA="invalid_data",X.INVALID_CREDENTIALS="invalid_credentials",X.INVALID_CAPTCHA="invalid_captcha",X.LINKED_TO_ANOTHER_USER="linked_to_another_user",X.ALLOWLIST_REJECTED="allowlist_rejected",X.CANNOT_UNLINK_EMBEDDED_WALLET="cannot_unlink_embedded_wallet",X.CANNOT_UNLINK_SOLE_ACCOUNT="cannot_unlink_sole_account",X.CANNOT_LINK_MORE_OF_TYPE="cannot_link_more_of_type",X.LINKED_ACCOUNT_NOT_FOUND="linked_account_not_found",X.TOO_MANY_REQUESTS="too_many_requests",X.RESOURCE_CONFLICT="resource_conflict",X.INVALID_ORIGIN="invalid_origin",X.MISSING_ORIGIN="missing_origin",X.INVALID_NATIVE_APP_ID="invalid_native_app_id",X.TOKEN_ALREADY_USED="token_already_used",X.ALREADY_LOGGED_OUT="already_logged_out",X.NOT_SUPPORTED="not_supported",X.USER_UNSUBSCRIBED="user_unsubscribed",X.MAX_APPS_REACHED="max_apps_reached",X.USER_LIMIT_REACHED="max_accounts_reached",X.DEVICE_REVOKED="device_revoked",X.WALLET_PASSWORD_EXISTS="wallet_password_exists",X.OAUTH_STATE_MISMATCH="oauth_state_mismatch",X.MAX_DENYLIST_ENTRIES_REACHED="max_denylist_entries_reached",X.MAX_TEST_ACCOUNTS_REACHED="max_test_accounts_reached",X.DISALLOWED_LOGIN_METHOD="disallowed_login_method",X.DISALLOWED_PLUS_EMAIL="disallowed_plus_email",X.DISALLOWED_RECOVERY_METHOD="disallowed_recovery_method",X.LEGACY_DASHBOARD_LOGIN_CONFIGURATION="legacy_dashboard_login_configuration",X.CANNOT_SET_PASSWORD="cannot_set_password",X.INVALID_PKCE_PARAMETERS="invalid_pkce_parameters",X.INVALID_APP_URL_SCHEME_CONFIGURATION="invalid_app_url_scheme_configuration",X.CROSS_APP_CONNECTION_NOT_ALLOWED="cross_app_connection_not_allowed",X.USER_DOES_NOT_EXIST="user_does_not_exist",X.ALREADY_EXISTS="resource_already_exists",X.ACCOUNT_TRANSFER_REQUIRED="account_transfer_required",X.USER_HAS_NOT_DELEGATED_WALLET="user_has_not_delegated_wallet",X.FEATURE_NOT_ENABLED="feature_not_enabled",X.INSUFFICIENT_FUNDS="insufficient_funds",X.TRANSACTION_BROADCAST_FAILURE="transaction_broadcast_failure",X.TRANSACTION_EXECUTION_FAILURE="transaction_execution_failure",X.INVALID_POLICY_FORMAT="invalid_policy_format",X.POLICY_VIOLATION="policy_violation",X.AUTHORIZATION_KEY_HAS_ASSOCIATED_WALLETS="authorization_key_has_associated_wallets",X.INVALID_REQUEST="invalid_request",X.SIGNUP_DISABLED="signup_disabled",X);e.s(["PrivyErrorCode",()=>Q],640692);let Z={path:"/api/v1/apps/:app_id",method:"GET"},ee={path:"/api/v1/analytics_events",method:"POST"},et={path:"/api/v1/sessions",method:"POST"},er={path:"/api/v1/sessions/logout",method:"POST"};var ei=g,es=e.i(903123),es=es;function ea(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var i in r)e[i]=r[i]}return e}var en=function e(t,r){function i(e,i,s){if("undefined"!=typeof document){"number"==typeof(s=ea({},r,s)).expires&&(s.expires=new Date(Date.now()+864e5*s.expires)),s.expires&&(s.expires=s.expires.toUTCString()),e=encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape);var a="";for(var n in s)s[n]&&(a+="; "+n,!0!==s[n]&&(a+="="+s[n].split(";")[0]));return document.cookie=e+"="+t.write(i,e)+a}}return Object.create({set:i,get:function(e){if("undefined"!=typeof document&&(!arguments.length||e)){for(var r=document.cookie?document.cookie.split("; "):[],i={},s=0;s<r.length;s++){var a=r[s].split("="),n=a.slice(1).join("=");try{var o=decodeURIComponent(a[0]);if(i[o]=t.read(n,o),e===o)break}catch(e){}}return e?i[e]:i}},remove:function(e,t){i(e,"",ea({},t,{expires:-1}))},withAttributes:function(t){return e(this.converter,ea({},this.attributes,t))},withConverter:function(t){return e(ea({},this.converter,t),this.attributes)}},{attributes:{value:Object.freeze(r)},converter:{value:Object.freeze(t)}})}({read:function(e){return'"'===e[0]&&(e=e.slice(1,-1)),e.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent)},write:function(e){return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,decodeURIComponent)}},{path:"/"});e.s(["default",()=>en],721018);var eo=e.i(850414);let ec=Promise.allSettled.bind(Promise)??(e=>Promise.all(e.map(e=>e.then(e=>({status:"fulfilled",value:e})).catch(e=>({status:"rejected",reason:e}))))),ed="privy:token",el="privy-token",eh="privy:pat",ep="privy:refresh_token",ey="privy-refresh-token",e_="privy:id-token",eu="privy-id-token",ev="privy-session";class em extends ei.default{set isUsingServerCookies(e){this._isUsingServerCookies=e}async getCustomerAccessToken(){let e=await this._storage.get(ed);try{return"string"==typeof e?new eo.Token(e).value:null}catch(e){return console.error(e),await this.destroyLocalState({reason:"getToken_error"}),null}}async getPrivyAccessToken(){let e=await this._storage.get(eh);try{return"string"==typeof e?new eo.Token(e).value:null}catch(e){return console.error(e),await this.destroyLocalState({reason:"getToken_error"}),null}}async getRefreshToken(){let e=await this._storage.get(ep);return"string"==typeof e?e:null}async getIdentityToken(){let e=await this._storage.get(e_);return"string"==typeof e?e:null}get mightHaveServerCookies(){try{let e=en.get(ev);return void 0!==e&&e.length>0}catch(e){console.error(e)}return!1}hasRefreshCredentials(e,t){return this.mightHaveServerCookies||"string"==typeof e&&"string"==typeof t}tokenIsActive(e){if(!e)return!1;let t=eo.Token.parse(e);return null!==t&&!t.isExpired(30)}async destroyLocalState(e){await ec([this._storage.del(ed),this._storage.del(ep),this._storage.del(e_),this._storage.del(this.GUEST_CREDENTIAL_STORAGE_KEY)]),en.remove(el),en.remove(ey),en.remove(eu),en.remove(ev),e?.reason&&this.emit("storage_cleared",{reason:e.reason})}async storeCustomerAccessToken(e){if("string"==typeof e){let t=await this._storage.get(ed);if(await this._storage.put(ed,e),!this._isUsingServerCookies){let t=eo.Token.parse(e)?.expiration;en.set(el,e,{sameSite:"Strict",secure:!0,expires:t?new Date(1e3*t):void 0})}t!==e&&this.emit("token_stored",{cookiesEnabled:this._isUsingServerCookies})}else{let e=await this._storage.get(ed);await this._storage.del(ed),en.remove(el),null!==e&&this.emit("token_cleared",{reason:"set_with_non_string_value"})}}async storePrivyAccessToken(e){"string"==typeof e?await this._storage.put(eh,e):await this._storage.del(eh)}async storeRefreshToken(e){"string"==typeof e?(await this._storage.put(ep,e),this._isUsingServerCookies||(en.set(ev,"t",{sameSite:"Strict",secure:!0,expires:30}),en.set(ey,e,{sameSite:"Strict",secure:!0,expires:30})),this.emit("refresh_token_stored",{cookiesEnabled:this._isUsingServerCookies})):(await this._storage.del(ep),en.remove(ey),en.remove(ev),this.emit("refresh_token_cleared",{reason:"set_with_non_string_value"}))}async updateWithTokensResponse(e){let t=(await ec([this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token),this.storeRefreshToken(e.refresh_token),this.storeIdentityToken(e.identity_token),this.processOAuthTokens(e.oauth_tokens)])).filter(e=>"rejected"===e.status);t.length>0&&this.emit("error_storing_tokens",t.map(e=>String(e.reason)).join(", "))}async processOAuthTokens(e){e&&this.emit("oauth_tokens_granted",e)}async storeIdentityToken(e){if("string"==typeof e){let t=await this._storage.get(e_);if(await this._storage.put(e_,e),!this._isUsingServerCookies){let t=eo.Token.parse(e)?.expiration;en.set(eu,e,{sameSite:"Strict",secure:!0,expires:t?new Date(1e3*t):void 0})}t!==e&&this.emit("identity_token_stored",{cookiesEnabled:this._isUsingServerCookies})}else{let e=await this._storage.get(e_);await this._storage.del(e_),en.remove(eu),null!==e&&this.emit("identity_token_cleared",{reason:"set_with_non_string_value"})}}async getOrCreateGuestCredential(){let e=this._storage.get(this.GUEST_CREDENTIAL_STORAGE_KEY);if(e&&"string"==typeof e)return e;let t=es.encode(crypto.getRandomValues(new Uint8Array(32)));return await this._storage.put(this.GUEST_CREDENTIAL_STORAGE_KEY,t),t}constructor(e){super(),this._isUsingServerCookies=!1,this._storage=e.storage,this.GUEST_CREDENTIAL_STORAGE_KEY=`privy:guest:${e.appId}`}}em.events=["storage_cleared","token_cleared","refresh_token_cleared","identity_token_cleared","token_stored","refresh_token_stored","identity_token_stored","oauth_tokens_granted","error_storing_tokens"];let eg=()=>{},ew={NONE:-1/0,ERROR:1,WARN:2,INFO:3,DEBUG:1/0},ef="privy:caid";class eI{setCallbacks(e){this.callbacks={...this.callbacks,...e}}get isReady(){return!!this._config}get config(){return this._config}get caid(){return this._analyticsId}async _initialize(){if(this.isReady)this.callbacks?.setIsReady?.(!0);else{if(!await this.isStorageAccessible())throw new n.PrivyClientError({code:"storage_error",error:"Unable to access storage"});this._config=await this.getAppConfig(),this._config?.custom_api_url&&(this.baseUrl=this._config.custom_api_url,this.session.isUsingServerCookies=!0),this.callbacks?.setIsReady?.(!0),this._sdkVersion.startsWith("react-auth:")||this.createAnalyticsEvent("sdk_initialize",{})}}getPath(e,{params:t,query:r}){let i;return`${this.baseUrl}${i=e.path,t?Object.entries(t).reduce((e,[t,r])=>e.replace(`:${t}`,`${r}`),i):i}${function(e){let t=new URLSearchParams;for(let r in e)null!=e[r]&&t.append(r,String(e[r]));return Array.from(t).length?"?"+t.toString():""}(r)}`}async fetch(e,{body:t,params:r,query:i,headers:s,onRequest:a=this._beforeRequest.bind(this)}){let o=new Request(this.getPath(e,{params:r,query:i}),{method:e.method,body:JSON.stringify(t),headers:s}),c=await a(o),d=await this._fetch(o,c),l=await d.json();if(d.status>299)throw new n.PrivyApiError(l);return l}async _beforeRequestWithoutInitialize(e){let t,r=await this.session.getPrivyAccessToken()??await this.session.getCustomerAccessToken(),i=new Headers(e.headers);i.set("privy-app-id",this.appId),this.appClientId&&i.set("privy-client-id",this.appClientId),i.set("privy-client",this._sdkVersion),r&&i.set("Authorization",`Bearer ${r}`),i.set("Content-Type","application/json"),i.set("Accept","application/json");let s=await this._getOrGenerateClientAnalyticsId();return s&&i.set("privy-ca-id",s),this.nativeAppIdentifier&&i.set("x-native-app-identifier",this.nativeAppIdentifier),{signal:(t=new AbortController,setTimeout(()=>t.abort(),2e4),t.signal),headers:i,credentials:"include"}}async beforeRequestWithoutRefresh(e){return await this._initialize(),this._beforeRequestWithoutInitialize(e)}async _beforeRequest(e){return await this._initialize(),await this.getAccessTokenInternal(),this.beforeRequestWithoutRefresh(e)}async getAppConfig(){return await this.fetch(Z,{params:{app_id:this.appId},onRequest:this._beforeRequestWithoutInitialize.bind(this)})}async _getOrGenerateClientAnalyticsId(){if(this._analyticsId)return this._analyticsId;try{let e=await this._storage.get(ef);if("string"==typeof e&&e.length>0)return this._analyticsId=e,e}catch(e){this.logger.error("Unable to load clientId",e)}try{this._analyticsId=J()}catch(e){this.logger.error("Unable to generate uuidv4",e)}if(this._analyticsId){try{await this._storage.put(ef,this._analyticsId)}catch(e){this.logger.error(`Unable to store clientId: ${this._analyticsId}`,e)}return this._analyticsId}}async destroyClientAnalyticsId(){try{return await this._storage.del(ef)}catch(e){this.logger.error("Unable to delete clientId",e)}}async createAnalyticsEvent(e,t){try{await this.fetch(ee,{body:{event_name:e,client_id:await this._getOrGenerateClientAnalyticsId(),payload:t},onRequest:this.beforeRequestWithoutRefresh.bind(this)})}catch(e){}}async refreshSession(e=!1){if(!await this.isStorageAccessible())throw new n.PrivyClientError({code:"storage_error",error:"Unable to access storage"});let t=await this.session.getRefreshToken()??void 0,r=t??"key",i=this._cache.get(r);if(i)return this.logger.debug("[privy:refresh] found in-flight session refresh request, deduping"),await i;let s=this._refreshSession(t,e);this._cache.set(r,s);try{return await s}finally{this._cache.delete(r)}}async _refreshSession(e,t){let r=await this.session.getCustomerAccessToken();if(!this.session.hasRefreshCredentials(r,e??null))throw this.logger.debug("[privy:refresh] missing tokens, skipping request"),await this._initialize(),new n.PrivyApiError({code:Q.MISSING_OR_INVALID_TOKEN,error:"No tokens found in storage"});try{this.logger.debug(`[privy:refresh] fetching: ${et.path}`);let r=await this.fetch(et,{body:{refresh_token:e},onRequest:this.beforeRequestWithoutRefresh.bind(this)}),i=r.session_update_action;return this.logger.debug(`[privy:refresh] response: ${i}`),t||this.callbacks?.setUser?.(r.user),"set"===i&&(await this.session.updateWithTokensResponse(r),this.logger.debug("[privy:refresh] tokens stored")),"clear"===i&&(await this.session.destroyLocalState(),this.logger.debug("[privy:refresh] tokens cleared"),t||this.callbacks?.setUser?.(null)),"ignore"===i&&r.token&&(await this.session.storeCustomerAccessToken(r.token),await this.session.storePrivyAccessToken(r.privy_access_token),this.logger.debug("[privy:refresh] access token stored"),r.identity_token&&(this.logger.debug("[privy:refresh] identity token stored"),await this.session.storeIdentityToken(r.identity_token))),this.logger.debug("[privy:refresh] returning response"),r}catch(e){throw this.logger.debug(`[privy:refresh] error: ${e.message??"unknown error"}`),e instanceof n.PrivyApiError&&e.code===Q.MISSING_OR_INVALID_TOKEN&&(await this.session.destroyLocalState(),t||this.callbacks?.setUser?.(null)),e}}async getAccessToken(){let[e,t]=await Promise.all([this.session.getCustomerAccessToken(),this.session.getRefreshToken()]);if(!this.session.tokenIsActive(e)&&this.session.hasRefreshCredentials(e,t)){let t=await this.refreshSession(),r=await this.session.getCustomerAccessToken();return t.token||this.logger.debug("[privy:getAccessToken] expected token received null"),t.token===e&&this.logger.debug("[privy:getAccessToken] expected new token in response received existing"),r===e&&this.logger.debug("[privy:getAccessToken] expected new token in storage received existing"),t.token??r}return e}async getAccessTokenInternal(){let e=await this.getAccessToken();return await this.session.getPrivyAccessToken()??e}async getIdentityToken(){return await this.session.getIdentityToken()}async isStorageAccessible(){try{let e=`privy:__storage__test-${J()}`,t="blobby";await this._storage.put(e,t);let r=await this._storage.get(e);return await this._storage.del(e),r===t}catch(e){return this.logger.error(e),!1}}constructor(e){this._sdkVersion="js-sdk-core:0.58.5",this._cache=new Map,this.logger=(({level:e}={level:"ERROR"})=>({get level(){return e},error:ew[e]>=ew.ERROR?console.error:eg,warn:ew[e]>=ew.WARN?console.warn:eg,info:ew[e]>=ew.INFO?console.info:eg,debug:ew[e]>=ew.DEBUG?console.debug:eg}))({level:e.logLevel??"ERROR"}),this._storage=e.storage,this._analyticsId=null,this._getOrGenerateClientAnalyticsId(),this.baseUrl=e.baseUrl??"https://auth.privy.io",this.appId=e.appId,this.appClientId=e.appClientId,this._sdkVersion=e.sdkVersion??this._sdkVersion,this.callbacks=e.callbacks,this.nativeAppIdentifier=e.nativeAppIdentifier,this.session=new em({storage:this._storage,isUsingServerCookies:!1,appId:e.appId}),this._fetch=(0,F.default)(globalThis.fetch,{retries:3,retryDelay:e=>3**e*500,retryOn:[408,409,425,500,502,503,504]}),this.session.on("error_storing_tokens",e=>{this.createAnalyticsEvent("error_updating_tokens_in_storage",{reason:e})})}}let ek={path:"/api/v1/users/me/accept_terms",method:"POST"};class eb{async get(){let{user:e}=await this._privyInternal.refreshSession();return{user:e}}async acceptTerms(){return{user:await this._privyInternal.fetch(ek,{})}}constructor(e){this._privyInternal=e}}let eT={path:"/api/v1/custom_jwt_account/authenticate",method:"POST"},eE=e=>"wallet"===e.type&&"privy"===e.wallet_client_type&&"embedded"===e.connector_type,eA=e=>e?e.linked_accounts.filter(eE).filter(e=>"ethereum"===e.chain_type).sort((e,t)=>e.wallet_index-t.wallet_index):[],eS=e=>eA(e).find(e=>0===e.wallet_index)??null,eP=e=>e?e.linked_accounts.filter(eE).filter(e=>"solana"===e.chain_type).sort((e,t)=>e.wallet_index-t.wallet_index):[],eR=async(e,t,r)=>{let i,s,a,n,o=(i=t.user,!("off"===(s=r?.ethereum?.createOnLogin??"off")||eA(i).length>0||i.linked_accounts.filter(e=>"wallet"===e.type&&"ethereum"===e.chain_type).length>0&&"all-users"!==s)),c=(a=t.user,!("off"===(n=r?.solana?.createOnLogin??"off")||eP(a).length>0||a.linked_accounts.filter(e=>"wallet"===e.type&&"solana"===e.chain_type).length>0&&"all-users"!==n));if(o&&c){let r=await e.create({recoveryMethod:"privy",skipCallbacks:!0});return{...await e.createSolana({ethereumAccount:eS(r.user)??void 0}),is_new_user:t.is_new_user,oauth_tokens:t.oauth_tokens}}return o?{...await e.create({recoveryMethod:"privy",solanaAccount:eP(t.user).find(e=>0===e.wallet_index)??null??void 0}),is_new_user:t.is_new_user,oauth_tokens:t.oauth_tokens}:c?{...await e.createSolana({ethereumAccount:eS(t.user)??void 0}),is_new_user:t.is_new_user,oauth_tokens:t.oauth_tokens}:t};class eO{async syncWithToken(e,t,r){let i=await this._privyInternal.fetch(eT,{body:{token:e,mode:r}});await this._privyInternal.session.updateWithTokensResponse(i);let s=await eR(this._embedded,i,t?.embedded);return this._privyInternal.callbacks?.setUser?.(s.user),s}constructor(e,t){this._privyInternal=e,this._embedded=t}}let eC={path:"/api/v1/passwordless/authenticate",method:"POST"},ex={path:"/api/v1/passwordless/init",method:"POST"},eU={path:"/api/v1/passwordless/link",method:"POST"},eN={path:"/api/v1/passwordless/unlink",method:"POST"},eM={path:"/api/v1/passwordless/update",method:"POST"};class eW{async sendCode(e,t){return this._privyInternal.fetch(ex,{body:{email:e,token:t}})}async loginWithCode(e,t,r,i){let s=await this._privyInternal.fetch(eC,{body:{email:e,code:t,mode:r}});await this._privyInternal.session.updateWithTokensResponse(s);let a=await eR(this._embedded,s,i?.embedded);return this._privyInternal.callbacks?.setUser?.(a.user),a}async linkWithCode(e,t){await this._privyInternal.fetch(eU,{body:{email:e,code:t}});let r=await this._privyInternal.refreshSession();return{user:r.user,identity_token:r.identity_token}}async updateEmail({oldEmailAddress:e,newEmailAddress:t,code:r}){await this._privyInternal.fetch(eM,{body:{oldAddress:e,newAddress:t,code:r}});let i=await this._privyInternal.refreshSession();return{user:i.user,identity_token:i.identity_token}}async unlink(e){await this._privyInternal.fetch(eN,{body:{address:e}});let t=await this._privyInternal.refreshSession();return{user:t.user,identity_token:t.identity_token}}constructor(e,t){this._privyInternal=e,this._embedded=t}}let eD={path:"/api/v1/farcaster/init",method:"POST"},eL={path:"/api/v1/farcaster/authenticate",method:"POST"},eV={path:"/api/v1/farcaster/link",method:"POST"},eq={path:"/api/v1/farcaster/unlink",method:"POST"},e$={path:"/api/v1/farcaster/status",method:"GET"},eF={path:"/api/v2/farcaster/init",method:"POST"},eG={path:"/api/v2/farcaster/authenticate",method:"POST"};class ez{async initializeAuth({relyingParty:e,redirectUrl:t,token:r}){return await this._privyInternal.fetch(eD,{body:{relying_party:e,redirect_url:t,token:r}})}async getFarcasterStatus({channel_token:e}){return await this._privyInternal.fetch(e$,{headers:{"farcaster-channel-token":e}})}async authenticate({channel_token:e,message:t,signature:r,fid:i,mode:s},a){let n=await this._privyInternal.fetch(eL,{body:{channel_token:e,message:t,signature:r,fid:i,mode:s}});await this._privyInternal.session.updateWithTokensResponse(n);let o=await eR(this._embedded,n,a?.embedded);return this._privyInternal.callbacks?.setUser?.(o.user),o}async link({channel_token:e,message:t,signature:r,fid:i}){await this._privyInternal.fetch(eV,{body:{channel_token:e,message:t,signature:r,fid:i}});let s=await this._privyInternal.refreshSession();return{user:s.user,identity_token:s.identity_token}}async unlink({fid:e}){await this._privyInternal.fetch(eq,{body:{fid:e}});let t=await this._privyInternal.refreshSession();return{user:t.user,identity_token:t.identity_token}}constructor(e,t){this._privyInternal=e,this._embedded=t}}class ej{async initializeAuth(){return await this._privyInternal.fetch(eF,{body:{}})}async authenticate({message:e,signature:t,fid:r},i){let s=await this._privyInternal.fetch(eG,{body:{message:e,signature:t,fid:r}});await this._privyInternal.session.updateWithTokensResponse(s);let a=await eR(this._embedded,s,i?.embedded);return this._privyInternal.callbacks?.setUser?.(a.user),a}constructor(e,t){this._privyInternal=e,this._embedded=t}}let eK={path:"/api/v1/guest/authenticate",method:"POST"};class eB{async create(e){let t=await this._privyInternal.session.getOrCreateGuestCredential(),r=await this._privyInternal.fetch(eK,{body:{guest_credential:t}});await this._privyInternal.session.updateWithTokensResponse(r);let i=await eR(this._embedded,r,e?.embedded);return this._privyInternal.callbacks?.setUser?.(i.user),i}constructor(e,t){this._privyInternal=e,this._embedded=t}}let eJ={path:"/api/v1/oauth/authenticate",method:"POST"},eH={path:"/api/v1/oauth/init",method:"POST"},eY={path:"/api/v1/oauth/link",method:"POST"},eX={path:"/api/v1/oauth/unlink",method:"POST"};var es=es;let eQ="privy:state_code",eZ="privy:code_verifier";async function e0(e,t){let r=(new TextEncoder).encode(e);return new Uint8Array(await t("SHA-256",r))}function e1(){return es.encode(crypto.getRandomValues(new Uint8Array(36)))}async function e2({codeVerifier:e,method:t="S256",digest:r=crypto.subtle.digest.bind(crypto.subtle)}){if("S256"!=t)return e;{let t=await e0(e,r);return es.encode(t)}}class e6{async generateURL(e,t){let r=e1(),i=e1(),s=await e2({codeVerifier:r,digest:this._crypto?.digest});return await Promise.all([this._storage.put(eZ,r),this._storage.put(eQ,i)]),this._privyInternal.fetch(eH,{body:{redirect_to:t,provider:e,code_challenge:s,state_code:i}})}async loginWithCode(e,t,r,i,s,a){let[o,c]=await Promise.all([this._storage.get(eZ),this._storage.get(eQ)]);if(c!==t)throw this._privyInternal.createAnalyticsEvent("possible_phishing_attempt",{flow:"oauth",provider:r,storedStateCode:c??"",returnedStateCode:t??""}),new n.PrivyClientError({code:"pkce_state_code_mismatch",error:"Unexpected auth flow. This may be a phishing attempt."});let d=await this._privyInternal.fetch(eJ,{body:{authorization_code:e,code_type:i,state_code:c,code_verifier:o,mode:s}});await this._privyInternal.session.updateWithTokensResponse(d);let l=await eR(this._embedded,d,a?.embedded);return await Promise.all([this._storage.del(eZ),this._storage.del(eQ)]),this._privyInternal.callbacks?.setUser?.(l.user),l}async linkWithCode(e,t,r,i){let[s,a]=await Promise.all([this._storage.get(eZ),this._storage.get(eQ)]);if(a!==t)throw this._privyInternal.createAnalyticsEvent("possible_phishing_attempt",{flow:"oauth",provider:r,storedStateCode:a??"",returnedStateCode:t??""}),new n.PrivyClientError({code:"pkce_state_code_mismatch",error:"Unexpected auth flow. This may be a phishing attempt."});let o=await this._privyInternal.fetch(eY,{body:{authorization_code:e,code_type:i,state_code:a,code_verifier:s}});await this._privyInternal.session.processOAuthTokens(o.oauth_tokens);let c=await this._privyInternal.refreshSession();return await Promise.all([this._storage.del(eZ),this._storage.del(eQ)]),{user:c.user,identity_token:c.identity_token}}async unlink(e,t){await this._privyInternal.fetch(eX,{body:{provider:e,subject:t}});let r=await this._privyInternal.refreshSession();return{user:r.user,identity_token:r.identity_token}}constructor(e,t,r,i){this._privyInternal=e,this._embedded=t,this._storage=r,this._crypto=i}}let e4={path:"/api/v1/passkeys/link",method:"POST"},e5={path:"/api/v1/passkeys/authenticate",method:"POST"},e8={path:"/api/v1/passkeys/register",method:"POST"},e3={path:"/api/v1/passkeys/authenticate/init",method:"POST"},e9={path:"/api/v1/passkeys/register/init",method:"POST"},e7={path:"/api/v1/passkeys/link/init",method:"POST"};class te{async generateRegistrationOptions(e){return await this._privyInternal.fetch(e7,{body:{relying_party:e}})}async generateAuthenticationOptions(e){return await this._privyInternal.fetch(e3,{body:{relying_party:e}})}async generateSignupOptions(e){return await this._privyInternal.fetch(e9,{body:{relying_party:e}})}async loginWithPasskey(e,t,r,i){let s=await this._privyInternal.fetch(e5,{body:{relying_party:r,challenge:t,authenticator_response:this._transformAuthenticationResponseToSnakeCase(e)}});await this._privyInternal.session.updateWithTokensResponse(s);let a=await eR(this._embedded,s,i?.embedded);return this._privyInternal.callbacks?.setUser?.(a.user),a}async signupWithPasskey(e,t,r){let i=await this._privyInternal.fetch(e8,{body:{relying_party:t,authenticator_response:this._transformRegistrationResponseToSnakeCase(e)}});await this._privyInternal.session.updateWithTokensResponse(i);let s=await eR(this._embedded,i,r?.embedded);return this._privyInternal.callbacks?.setUser?.(s.user),s}async linkWithPasskey(e,t){await this._privyInternal.fetch(e4,{body:{relying_party:t,authenticator_response:this._transformRegistrationResponseToSnakeCase(e)}});let r=await this._privyInternal.refreshSession();return{user:r.user,identity_token:r.identity_token}}_transformRegistrationResponseToSnakeCase(e){return{type:e.type,id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,attestation_object:e.response.attestationObject,authenticator_data:e.response.authenticatorData||void 0,transports:e.response.transports||void 0,public_key:e.response.publicKey||void 0,public_key_algorithm:e.response.publicKeyAlgorithm||void 0},authenticator_attachment:e.authenticatorAttachment||void 0,client_extension_results:{app_id:e.clientExtensionResults.appid||void 0,cred_props:e.clientExtensionResults.credProps||void 0,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret||void 0}}}_transformAuthenticationResponseToSnakeCase(e){return{type:e.type,id:e.id,raw_id:e.rawId,response:{signature:e.response.signature,client_data_json:e.response.clientDataJSON,authenticator_data:e.response.authenticatorData,user_handle:e.response.userHandle||void 0},authenticator_attachment:e.authenticatorAttachment||void 0,client_extension_results:{app_id:e.clientExtensionResults.appid||void 0,cred_props:e.clientExtensionResults.credProps||void 0,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret||void 0}}}constructor(e,t){this._privyInternal=e,this._embedded=t}}let tt={path:"/api/v1/passwordless_sms/authenticate",method:"POST"},tr={path:"/api/v1/passwordless_sms/init",method:"POST"},ti={path:"/api/v1/passwordless_sms/link",method:"POST"},ts={path:"/api/v1/passwordless_sms/unlink",method:"POST"},ta={path:"/api/v1/passwordless_sms/update",method:"POST"};class tn{async sendCode(e,t){return this._privyInternal.fetch(tr,{body:{phoneNumber:e,token:t}})}async loginWithCode(e,t,r,i){let s=await this._privyInternal.fetch(tt,{body:{phoneNumber:e,code:t,mode:r}});await this._privyInternal.session.updateWithTokensResponse(s);let a=await eR(this._embedded,s,i?.embedded);return this._privyInternal.callbacks?.setUser?.(a.user),a}async linkWithCode(e,t){await this._privyInternal.fetch(ti,{body:{phoneNumber:e,code:t}});let r=await this._privyInternal.refreshSession();return{user:r.user,identity_token:r.identity_token}}async updatePhone({oldPhoneNumber:e,newPhoneNumber:t,code:r}){await this._privyInternal.fetch(ta,{body:{old_phone_number:e,new_phone_number:t,code:r}});let i=await this._privyInternal.refreshSession();return{user:i.user,identity_token:i.identity_token}}async unlink(e){await this._privyInternal.fetch(ts,{body:{phoneNumber:e}});let t=await this._privyInternal.refreshSession();return{user:t.user,identity_token:t.identity_token}}constructor(e,t){this._privyInternal=e,this._embedded=t}}let to={path:"/api/v1/siwe/init",method:"POST"},tc={path:"/api/v1/siwe/authenticate",method:"POST"},td={path:"/api/v1/siwe/link",method:"POST"},tl={path:"/api/v1/siwe/link_smart_wallet",method:"POST"},th={path:"/api/v1/siwe/unlink",method:"POST"};class tp{async unlinkWallet(e){await this._privyInternal.fetch(th,{body:{address:e}});let t=await this._privyInternal.refreshSession();return{user:t.user,identity_token:t.identity_token}}async linkWithSiwe(e,t,r){let i=t||this._wallet,s=r||this._preparedMessage;if(!i)throw Error("A wallet must be provided in the init step or as an argument to linkWithSiwe");if(!s)throw Error("A message must be generated and signed before being used to link a wallet to privy");await this._privyInternal.fetch(td,{body:{message:s,signature:e,chainId:i.chainId,walletClientType:i.walletClientType??null,connectorType:i.connectorType??null}});let a=await this._privyInternal.refreshSession();return{user:a.user,identity_token:a.identity_token}}async loginWithSiwe(e,t,r,i,s){let a=t||this._wallet,n=r||this._preparedMessage;if(!a)throw Error("A wallet must be provided in the init step or as an argument to loginWithSiwe");if(!n)throw Error("A message must be generated and signed before being used to login to privy with a wallet");let o=await this._privyInternal.fetch(tc,{body:{signature:e,message:n,chainId:a.chainId,walletClientType:a.walletClientType??null,connectorType:a.connectorType??null,mode:i}});await this._privyInternal.session.updateWithTokensResponse(o);let c=await eR(this._embedded,o,s?.embedded);return this._privyInternal.callbacks?.setUser?.(c.user),c}async init(e,t,r){var i;this._wallet=e;let{nonce:s}=await this._privyInternal.fetch(to,{body:{address:e.address}}),a=`${(i={chainId:e.chainId.toString().replace("eip155:",""),address:e.address,issuedAt:(new Date).toISOString(),statement:"By signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.",domain:t,nonce:s,uri:r}).domain} wants you to sign in with your Ethereum account:
${i.address}

${i.statement}

URI: ${i.uri}
Version: 1
Chain ID: ${i.chainId}
Nonce: ${i.nonce}
Issued At: ${i.issuedAt}
Resources:
- https://privy.io`;return this._preparedMessage=a,{nonce:s,message:a}}constructor(e,t){this._wallet=void 0,this._privyInternal=e,this._embedded=t}}let ty={path:"/api/v1/siws/init",method:"POST"},t_={path:"/api/v1/siws/authenticate",method:"POST"},tu={path:"/api/v1/siws/link",method:"POST"},tv={path:"/api/v1/siws/unlink",method:"POST"};class tm{async unlink({address:e}){await this._privyInternal.fetch(tv,{body:{address:e}});let t=await this._privyInternal.refreshSession();return{user:t.user,identity_token:t.identity_token}}async link({message:e,signature:t,walletClientType:r,connectorType:i}){await this._privyInternal.fetch(tu,{body:{message:e,signature:t,walletClientType:r??null,connectorType:i??null}});let s=await this._privyInternal.refreshSession();return{user:s.user,identity_token:s.identity_token}}async login({mode:e,message:t,signature:r,walletClientType:i,connectorType:s,opts:a}){let n=await this._privyInternal.fetch(t_,{body:{signature:r,message:t,walletClientType:i??null,connectorType:s??null,mode:e}});await this._privyInternal.session.updateWithTokensResponse(n);let o=await eR(this._embedded,n,a?.embedded);return this._privyInternal.callbacks?.setUser?.(o.user),o}async fetchNonce({address:e}){let{nonce:t}=await this._privyInternal.fetch(ty,{body:{address:e}});return{nonce:t}}constructor(e,t){this._privyInternal=e,this._embedded=t}}class tg{async link(e,t,r,i){await this._privyInternal.fetch(tl,{body:{message:e,signature:t,smart_wallet_type:r,smart_wallet_version:i}});let s=await this._privyInternal.refreshSession();return{user:s.user,identity_token:s.identity_token}}async init(e){var t;let{nonce:r}=await this._privyInternal.fetch(to,{body:{address:e.address}});return{nonce:r,message:`${(t={chainId:e.chainId.toString().replace("eip155:",""),address:e.address,issuedAt:(new Date).toISOString(),statement:"By signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.",domain:"privy.io",uri:"https://auth.privy.io",nonce:r}).domain} wants you to sign in with your Ethereum account:
${t.address}

${t.statement}

URI: ${t.uri}
Version: 1
Chain ID: ${t.chainId}
Nonce: ${t.nonce}
Issued At: ${t.issuedAt}
Resources:
- https://privy.io`}}constructor(e){this._privyInternal=e}}class tw{async logout(e){try{let e=await this._privyInternal.session.getRefreshToken()??void 0;await this._privyInternal.fetch(er,{body:{refresh_token:e}})}catch(e){console.warn("Error destroying session")}await Promise.all([this._privyInternal.session.destroyLocalState({reason:"logout"}),this._privyInternal.destroyClientAnalyticsId(),e?.userId&&this._mfa.clearMfa({userId:e.userId})]),this._privyInternal.callbacks?.setUser?.(null)}constructor(e,t,r,i,s){this._privyInternal=e,this._mfa=s,this.customProvider=new eO(this._privyInternal,t),this.phone=new tn(this._privyInternal,t),this.email=new eW(this._privyInternal,t),this.oauth=new e6(this._privyInternal,t,r,i),this.guest=new eB(this._privyInternal,t),this.siwe=new tp(this._privyInternal,t),this.siws=new tm(this._privyInternal,t),this.smartWallet=new tg(this._privyInternal),this.passkey=new te(this._privyInternal,t),this.farcaster=new ez(this._privyInternal,t),this.farcasterV2=new ej(this._privyInternal,t)}}let tf={path:"/api/v1/funding/coinbase_on_ramp/init",method:"POST"},tI={path:"/api/v1/funding/coinbase_on_ramp/status",method:"GET"};class tk{async initOnRampSession(e){return await this._privyInternal.fetch(tf,{body:e})}async getStatus(e){return await this._privyInternal.fetch(tI,{query:{partnerUserId:e}})}constructor(e){this._privyInternal=e}}let tb={path:"/api/v1/plugins/moonpay_on_ramp/sign",method:"POST"};var tT=e.i(573058);class tE{async sign(e){return await this._privyInternal.fetch(tb,{body:e})}async getTransactionStatus({transactionId:e,useSandbox:t}){let{url:r,key:i}=tT.MoonpayEnvironments[t?"sandbox":"prod"],s=await (0,F.default)(fetch,{retries:3,retryDelay:500})(`${r}/transactions/ext/${e}?apiKey=${i}`);if(!s.ok)throw new n.MoonpayApiError({error:`Failed to fetch transaction status for Transaction ${e}`,code:"failed_to_fetch_moonpay_transaction_status",response:s});let a=await s.json();return Array.isArray(a)?a.at(0):void 0}constructor(e){this._privyInternal=e}}class tA{constructor(e){this.moonpay=new tE(e),this.coinbase=new tk(e)}}let tS={path:"/api/v1/mfa/passkeys/init",method:"POST"};class tP{async generateAuthenticationOptions(e){return await this._privyInternal.fetch(tS,{body:e})}constructor(e){this._privyInternal=e}}let tR={path:"/api/v1/mfa/passwordless_sms/init",method:"POST"};class tO{async sendCode(e){return await this._privyInternal.fetch(tR,{body:e})}constructor(e){this._privyInternal=e}}class tC{setProxy(e){this.proxy=e}async getAccessTokenInternal(){let e=await this.privyInternal.getAccessTokenInternal();if(!e)throw new n.PrivyClientError({error:"Missing access token",code:"attempted_rpc_call_before_logged_in"});return e}async verifyMfa(){if(!this.proxy)throw new n.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_webview_not_loaded"});return await this.proxy.verifyMfa({accessToken:await this.getAccessTokenInternal()})}async initEnrollMfa(e){if(!this.proxy)throw new n.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_webview_not_loaded"});return await this.proxy.initEnrollMfa({...e,accessToken:await this.getAccessTokenInternal()})}async submitEnrollMfa(e){if(!this.proxy)throw new n.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_webview_not_loaded"});let t=await this.proxy.submitEnrollMfa({...e,accessToken:await this.getAccessTokenInternal()});return await this.privyInternal.refreshSession(),t}async unenrollMfa(e){if(!this.proxy)throw new n.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_webview_not_loaded"});let t=await this.proxy.unenrollMfa({method:e,accessToken:await this.getAccessTokenInternal()});return await this.privyInternal.refreshSession(),t}async clearMfa(e){if(!this.proxy)throw new n.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_webview_not_loaded"});return await this.proxy.clearMfa(e)}constructor(e,t){this.proxy=t,this.privyInternal=e,this.sms=new tO(e),this.passkey=new tP(e)}}let tx={path:"/api/v1/embedded_wallets/:address/recovery/key_material",method:"POST"},tU={path:"/api/v1/recovery/oauth/init",method:"POST"},tN={path:"/api/v1/recovery/oauth/authenticate",method:"POST"},tM={path:"/api/v1/recovery/oauth/init_icloud",method:"POST"},tW={path:"/api/v1/recovery/configuration_icloud",method:"POST"},tD=class{async init(e){return this._privyInternal.fetch(tM,{body:{client_type:e}})}async getICloudConfiguration(e){return this._privyInternal.fetch(tW,{body:{client_type:e}})}constructor(e){this._privyInternal=e}};class tL{async generateURL(e){let t=e1(),r=e1(),i=await e2({codeVerifier:t,digest:this._crypto?.digest});return await Promise.all([this._storage.put(eZ,t),this._storage.put(eQ,r)]),this._privyInternal.fetch(tU,{body:{redirect_to:e,code_challenge:i,state_code:r}})}async authorize(e,t){let[r,i]=await Promise.all([this._storage.get(eZ),this._storage.get(eQ)]);if(i!==t)throw this._privyInternal.createAnalyticsEvent("possible_phishing_attempt",{flow:"recovery_oauth",storedStateCode:i??"",returnedStateCode:t??""}),new n.PrivyClientError({code:"pkce_state_code_mismatch",error:"Unexpected auth flow. This may be a phishing attempt."});let s=await this._privyInternal.fetch(tN,{body:{authorization_code:e,state_code:i,code_verifier:r}});return await Promise.all([this._storage.del(eZ),this._storage.del(eQ)]),s}constructor(e,t,r){this._privyInternal=e,this._storage=t,this._crypto=r}}class tV{async getRecoveryKeyMaterial(e,t){return this._privyInternal.fetch(tx,{body:{chain_type:t},params:{address:e}})}constructor(e,t,r){this._privyInternal=e,this.auth=new tL(this._privyInternal,t,r),this.icloudAuth=new tD(this._privyInternal)}}class tq{async initialize(){await this._privyInternal._initialize()}setMessagePoster(e){this.embeddedWallet.setMessagePoster(e)}addOAuthTokensListener(e){return this._privyInternal.session.on("oauth_tokens_granted",e),{unsubscribe:()=>{this._privyInternal.session.removeListener("oauth_tokens_granted",e)}}}setCallbacks(e){this._privyInternal.setCallbacks(e)}getAccessToken(){return this._privyInternal.getAccessToken()}getIdentityToken(){return this._privyInternal.getIdentityToken()}getCompiledPath(e,t){return this._privyInternal.getPath(e,t)}async fetchPrivyRoute(e,t){return this._privyInternal.fetch(e,t)}get logger(){return this._privyInternal.logger}constructor({clientId:e,...s}){this._privyInternal=new eI({...s,appClientId:e}),this.mfa=new tC(this._privyInternal),this.mfaPromises=new $,this.app=new t.default(this._privyInternal),this.embeddedWallet=new V(this._privyInternal,s.embeddedWalletMessagePoster,s.supportedChains,this.mfa,this.mfaPromises,this.app),this.user=new eb(this._privyInternal),this.auth=new tw(this._privyInternal,this.embeddedWallet,s.storage,s.crypto,this.mfa),this.recovery=new tV(this._privyInternal,s.storage,s.crypto),this.funding=new tA(this._privyInternal),this.delegated=new i.default(this._privyInternal),this.crossApp=new r.default(this._privyInternal,s.storage)}}e.s(["default",()=>tq],926485);var t$=e.i(467174),tF=e.i(539285);let tG=()=>{let{walletProxy:e,client:t}=(0,tF.u)();return(0,t$.useMemo)(()=>({signWithUserSigner:async({message:r,targetAppId:i})=>{if(!e)throw Error("Wallet proxy not initialized");let s=await t.getAccessToken();if(!s)throw Error("User must be authenticated");let{signature:a}=await e.signWithUserSigner({accessToken:s,message:r,targetAppId:i});return{signature:a}}}),[e,t])};e.s(["u",()=>tG],237446)}]);