module.exports=[535349,475231,370147,477784,759939,191470,853612,502108,515875,a=>{"use strict";let b,c={path:"/api/v1/apps/:app_id/smart_wallets",method:"GET"};class d{getConfig(){return this._privyInternal.config}async getSmartWalletConfig(){return this._smartWalletConfig||(this._smartWalletConfig=await this._privyInternal.fetch(c,{params:{app_id:this.appId}})),this._smartWalletConfig}get appId(){return this._privyInternal.appId}constructor(a){this._privyInternal=a}}a.s(["default",()=>d],535349);let e={path:"/api/v1/apps/:app_id/cross-app/connections",method:"GET"};var f=a.i(500874);new TextEncoder;let g=new TextDecoder;b=f.Buffer.isEncoding("base64url")?a=>f.Buffer.from(a).toString("base64url"):a=>f.Buffer.from(a).toString("base64").replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_");let h=a=>{let b;return f.Buffer.from(((b=a)instanceof Uint8Array&&(b=g.decode(b)),b),"base64")};a.s(["decode",0,h,"encode",0,b],475231);class i extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(a){var b;super(a),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,null==(b=Error.captureStackTrace)||b.call(Error,this,this.constructor)}}class j extends i{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class k{static parse(a){try{return new k(a)}catch(a){return null}}get subject(){return this._decoded.sub}get expiration(){return this._decoded.exp}get issuer(){return this._decoded.iss}get audience(){return this._decoded.aud}isExpired(a=0){return Date.now()>=1e3*(this.expiration-a)}constructor(a){this.value=a,this._decoded=function(a){let b,c;if("string"!=typeof a)throw new j("JWTs must use Compact JWS serialization, JWT must be a string");let{1:d,length:e}=a.split(".");if(5===e)throw new j("Only JWTs using Compact JWS serialization can be decoded");if(3!==e)throw new j("Invalid JWT");if(!d)throw new j("JWTs must contain a payload");try{b=h(d)}catch{throw new j("Failed to base64url decode the payload")}try{c=JSON.parse(g.decode(b))}catch{throw new j("Failed to parse the decoded payload as JSON")}if(!function(a){if("object"!=typeof a||null===a||"[object Object]"!==Object.prototype.toString.call(a))return!1;if(null===Object.getPrototypeOf(a))return!0;let b=a;for(;null!==Object.getPrototypeOf(b);)b=Object.getPrototypeOf(b);return Object.getPrototypeOf(a)===b}(c))throw new j("Invalid JWT Claims Set");return c}(a)}}a.s(["Token",()=>k],370147);class l{async updateOnCrossAppAuthentication(a,b){let c=b.access_token,d=l.providerAccessTokenStorageKey(a);await this._storage.put(d,c)}async getProviderAccessToken(a){let b=l.providerAccessTokenStorageKey(a),c=await this._storage.get(b);if("string"!=typeof c)return null;try{if(new k(c).isExpired())throw Error("JWT is expired");return c}catch{return await this._storage.del(b),null}}async getCrossAppConnections(){return await this._privyInternal.fetch(e,{params:{app_id:this._privyInternal.appId}})}constructor(a,b){this._privyInternal=a,this._storage=b}}l.providerAccessTokenStorageKey=a=>`privy:cross-app:${a}`,a.s(["default",()=>l],477784);var m=a.i(908046);class n{async revoke(){await this._privyInternal.fetch(m.WalletsRevoke,{})}constructor(a){this._privyInternal=a}}a.s(["default",()=>n],759939);class o extends Error{constructor({error:a,code:b}){super(a),this.error=a,this.code=b}}class p extends Error{constructor({error:a,code:b}){super(a),this.code=b,this.error=a}}class q extends Error{constructor({error:a,code:b,response:c}){super(a),this.code=b,this.error=a,this.response=c}}a.s(["MoonpayApiError",()=>q,"PrivyApiError",()=>o,"PrivyClientError",()=>p],191470);let r=a=>!!a.id&&"privy-v2"===a.recovery_method;a.s(["isUnifiedWallet",()=>r],853612);class s{async sign({message:a}){return await this.request({method:"sign",params:{message:new TextDecoder("utf8").decode(a)}})}async signTransaction({psbt:a}){return await this.request({method:"signTransaction",params:{psbt:a}})}async request(a){if(r(this._account))throw new p({code:"unsupported_wallet_type",error:"Bitcoin wallet providers are only supported for on-device execution and this app uses TEE execution. Use the useSignRawHash hook from @privy-io/expo/extended-chains to sign over a hash with this wallet. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide"});if(!await this._privyInternal.getAccessTokenInternal())throw new p({error:"Missing access token",code:"attempted_rpc_call_before_logged_in"});return this.handleIFrameRpc(a)}async handleIFrameRpc(a){try{let b=await this._privyInternal.getAccessTokenInternal();if(!b)throw Error("Missing access token. User must be authenticated.");return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:a.method,address:this._account.address}),(await this._proxy.rpcWallet({accessToken:b,request:a,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,hdWalletIndex:this._account.wallet_index,chainType:this._account.chain_type})).response.data}catch(c){console.error(c);let b=c instanceof Error?c.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:a.method,address:this._account.address,error:b}),new p({code:"embedded_wallet_request_error",error:b})}}toJSON(){return`PrivyEmbeddedBitcoinProvider { address: '${this._account.address}', request: [Function] }`}constructor({proxy:a,privyInternal:b,account:c,entropyId:d,entropyIdVerifier:e}){this._proxy=a,this._privyInternal=b,this._account=c,this._entropyId=d,this._entropyIdVerifier=e}}a.s(["EmbeddedBitcoinWalletProvider",()=>s],502108);var t=a.i(60521);async function u({context:a,chainType:b}){return{wallet:await (0,t.create)(a,{request:{chain_type:b,owner_id:void 0}})}}a.s(["walletCreate",()=>u],515875)},676778,a=>{"use strict";var b=a.i(308493),c=a.i(112236),d=a.i(994575);let e=(a,e,g,h)=>{let i=Number(a),j=e.find(a=>a.id===i);if(!j)throw new d.PrivyConnectorError(`Unsupported chainId ${a}`,4901);return(0,b.createPublicClient)({transport:(0,c.http)(f(j,g,h.appId)),chain:j})},f=(a,b,c)=>{let e,f=a.id,g=Number(a.id);if(a.rpcUrls.privyWalletOverride&&a.rpcUrls.privyWalletOverride.http[0])e=a.rpcUrls.privyWalletOverride.http[0];else if(b.rpcUrls&&b.rpcUrls[g])e=b.rpcUrls[g];else if(a.rpcUrls.privy?.http[0]){let b=new URL(a.rpcUrls.privy.http[0]);b.searchParams.append("privyAppId",c),e=b.toString()}else e=a.rpcUrls.public?.http[0]?a.rpcUrls.public.http[0]:a.rpcUrls.default?.http[0];if(!e)throw new d.PrivyConnectorError(`No RPC url found for ${f}`);return e};function g({currentRecoveryMethod:a,upgradeToRecoveryMethod:b}){switch(a){case"privy":case"user-passcode":case"recovery-encryption-key":return!0;case"icloud":case"google-drive":if(a===b)throw Error("Cannot upgrade to the existing cloud platform");return!0;default:throw Error("Unknown recovery method")}}a.s(["getJsonRpcEndpointFromChain",()=>f,"getPublicClient",()=>e,"throwIfInvalidRecoveryUpgradePath",()=>g])},122500,(a,b,c)=>{"use strict";b.exports=function a(b){if("number"==typeof b&&isNaN(b))throw Error("NaN is not allowed");if("number"==typeof b&&!isFinite(b))throw Error("Infinity is not allowed");if(null===b||"object"!=typeof b)return JSON.stringify(b);if(b.toJSON instanceof Function)return a(b.toJSON());if(Array.isArray(b)){let c=b.reduce((b,c,d)=>`${b}${0===d?"":","}${a(void 0===c||"symbol"==typeof c?null:c)}`,"");return`[${c}]`}let c=Object.keys(b).sort().reduce((c,d)=>{if(void 0===b[d]||"symbol"==typeof b[d])return c;let e=0===c.length?"":",";return`${c}${e}${a(d)}:${a(b[d])}`},"");return`{${c}}`}},248055,(a,b,c)=>{"use strict";function d(a){return Number.isInteger(a)&&a>=0}function e(a){this.name="ArgumentError",this.message=a}b.exports=function(a,b){if(b=b||{},"function"!=typeof a)throw new e("fetch must be a function");if("object"!=typeof b)throw new e("defaults must be an object");if(void 0!==b.retries&&!d(b.retries))throw new e("retries must be a positive integer");if(void 0!==b.retryDelay&&!d(b.retryDelay)&&"function"!=typeof b.retryDelay)throw new e("retryDelay must be a positive integer or a function returning a positive integer");if(void 0!==b.retryOn&&!Array.isArray(b.retryOn)&&"function"!=typeof b.retryOn)throw new e("retryOn property expects an array or function");return b=Object.assign({retries:3,retryDelay:1e3,retryOn:[]},b),function(c,f){var g=b.retries,h=b.retryDelay,i=b.retryOn;if(f&&void 0!==f.retries)if(d(f.retries))g=f.retries;else throw new e("retries must be a positive integer");if(f&&void 0!==f.retryDelay)if(d(f.retryDelay)||"function"==typeof f.retryDelay)h=f.retryDelay;else throw new e("retryDelay must be a positive integer or a function returning a positive integer");if(f&&f.retryOn)if(Array.isArray(f.retryOn)||"function"==typeof f.retryOn)i=f.retryOn;else throw new e("retryOn property expects an array or function");return new Promise(function(b,d){var e=function(e){a("undefined"!=typeof Request&&c instanceof Request?c.clone():c,f).then(function(a){if(Array.isArray(i)&&-1===i.indexOf(a.status))b(a);else if("function"==typeof i)try{return Promise.resolve(i(e,null,a)).then(function(c){c?j(e,null,a):b(a)}).catch(d)}catch(a){d(a)}else e<g?j(e,null,a):b(a)}).catch(function(a){if("function"==typeof i)try{Promise.resolve(i(e,a,null)).then(function(b){b?j(e,a,null):d(a)}).catch(function(a){d(a)})}catch(a){d(a)}else e<g?j(e,a,null):d(a)})};function j(a,b,c){setTimeout(function(){e(++a)},"function"==typeof h?h(a,b,c):h)}e(0)})}}},840741,967107,760331,620253,178825,389337,814465,602275,a=>{"use strict";var b=a.i(535349),c=a.i(477784),d=a.i(759939),e=a.i(673593),f=a.i(698422),g=a.i(191470),h=a.i(502108),i=a.i(994575),j=a.i(515875),k=a.i(676778),l=a.i(853612);async function m(a,b,c,d,e=!1,f,g){let h=e,j=async f=>{if(h){f===+!e?d():c.current?.reject(new i.PrivyIframeError("missing_or_invalid_mfa","MFA verification failed, retry."));let h=await new Promise((a,d)=>{b.current={resolve:a,reject:d},setTimeout(()=>{let a=new i.PrivyIframeError("mfa_timeout","Timed out waiting for MFA code");c.current?.reject(a),d(a)},g)});return await a(h)}return await a()},k=null;for(let a=0;a<f;a++)try{k=await j(a),c.current?.resolve(void 0);break}catch(a){if("missing_or_invalid_mfa"!==a.type)throw c.current?.resolve(void 0),a;h=!0}if(null===k){let a=new i.PrivyIframeError("mfa_verification_max_attempts_reached","Max MFA verification attempts reached");throw c.current?.reject(a),a}return k}let n=(W=0,()=>"id-"+W++),o=(a,b)=>"bigint"==typeof b?b.toString():b,p=async(a,{ms:b,msg:c})=>{let d,e=new Promise((a,e)=>{d=setTimeout(()=>{e(Error(c))},b??15e3)});try{return await Promise.race([a,e])}finally{void 0!==d&&clearTimeout(d)}},q=new class{enqueue(a,b){this.callbacks[a]=b}dequeue(a,b){let c=this.callbacks[b];if(!c)throw Error(`cannot dequeue ${a} event: no event found for id ${b}`);switch(delete this.callbacks[b],a){case"privy:iframe:ready":case"privy:wallets:create":case"privy:user-signer:sign":case"privy:wallets:add":case"privy:wallets:set-recovery":case"privy:wallets:connect":case"privy:wallets:recover":case"privy:wallets:rpc":case"privy:wallet:create":case"privy:wallet:connect":case"privy:wallet:recover":case"privy:wallet:rpc":case"privy:solana-wallet:create":case"privy:solana-wallet:create-additional":case"privy:solana-wallet:connect":case"privy:solana-wallet:recover":case"privy:solana-wallet:rpc":case"privy:delegated-actions:consent":case"privy:mfa:verify":case"privy:mfa:init-enrollment":case"privy:mfa:submit-enrollment":case"privy:mfa:unenroll":case"privy:mfa:clear":return c;default:throw Error(`invalid wallet event type ${a}`)}}constructor(){this.callbacks={}}};class r{invokeWithMfa(a,b){return p(m(c=>p(this.waitForReady().then(()=>a(c)),{msg:b.timeoutMsg,ms:b.timeoutMs}),this.mfa.rootPromise,this.mfa.submitPromise,()=>this.mfa.emit("mfaRequired"),b.mfaAlwaysRequired??!1,4,3e5),{msg:"Operation reached timeout: MFA verification",ms:126e4})}reload(){return this.ready=!1,this._embeddedWalletMessagePoster.reload()}ping(a=15e3){return p(this.invoke("privy:iframe:ready",{}),{msg:"Ping reached timeout",ms:a})}create(a){return p(this.waitForReady().then(()=>this.invoke("privy:wallet:create",a)),{msg:"Operation reached timeout: create"})}rpc(a){return this.invokeWithMfa(b=>this.invoke("privy:wallet:rpc",{...b,...a}),{timeoutMsg:"Operation reached timeout: rpc"})}createSolana(a){return this.invokeWithMfa(b=>this.invoke("privy:solana-wallet:create",{...b,...a}),{timeoutMsg:"Operation reached timeout: create",timeoutMs:6e4})}createAdditionalSolana(a){return p(this.waitForReady().then(()=>this.invoke("privy:solana-wallet:create-additional",a)),{msg:"Operation reached timeout: create"})}solanaRpc(a){return this.invokeWithMfa(b=>this.invoke("privy:solana-wallet:rpc",{...b,...a}),{timeoutMsg:"Operation reached timeout: solana-rpc"})}delegateWallets(a){return this.invokeWithMfa(b=>this.invoke("privy:delegated-actions:consent",{...b,...a}),{timeoutMsg:"Operation reached timeout: delegated-actions:consent"})}verifyMfa(a){return this.invokeWithMfa(b=>this.invoke("privy:mfa:verify",{...b,...a}),{timeoutMsg:"Operation reached timeout: mfa:verify",mfaAlwaysRequired:!0})}initEnrollMfa(a){return this.invokeWithMfa(b=>this.invoke("privy:mfa:init-enrollment",{...b,...a}),{timeoutMsg:"Operation reached timeout: mfa:init-enrollment"})}submitEnrollMfa(a){return this.invokeWithMfa(b=>this.invoke("privy:mfa:submit-enrollment",{...b,...a}),{timeoutMsg:"Operation reached timeout: mfa:submit-enrollment"})}unenrollMfa(a){return this.invokeWithMfa(b=>this.invoke("privy:mfa:unenroll",{...b,...a}),{timeoutMsg:"Operation reached timeout: mfa:unenroll",mfaAlwaysRequired:!0})}clearMfa(a){return p(this.waitForReady().then(()=>this.invoke("privy:mfa:clear",a)),{msg:"Operation reached timeout: mfa:clear"})}createWallet(a){return this.invokeWithMfa(b=>this.invoke("privy:wallets:create",{...b,...a}),{timeoutMsg:"Operation reached timeout: create",timeoutMs:6e4})}signWithUserSigner(a){return this.invokeWithMfa(b=>this.invoke("privy:user-signer:sign",{...b,...a}),{timeoutMsg:"Operation reached timeout: user-signer:sign"})}addWallet(a){return p(this.waitForReady().then(()=>this.invoke("privy:wallets:add",a)),{msg:"Operation reached timeout: wallets:add"})}setRecovery(a){return this.invokeWithMfa(b=>this.invoke("privy:wallets:set-recovery",{...b,...a}),{timeoutMsg:"Operation reached timeout: wallets:set-recovery",timeoutMs:6e4})}connect(a){return p(this.waitForReady().then(()=>this.invoke("privy:wallets:connect",a)),{msg:"Operation reached timeout: wallets:connect"})}recover(a){return this.invokeWithMfa(b=>this.invoke("privy:wallets:recover",{...b,...a}),{timeoutMsg:"Operation reached timeout: wallets:recover",timeoutMs:6e4})}rpcWallet(a){return this.invokeWithMfa(b=>this.invoke("privy:wallets:rpc",{...b,...a}),{timeoutMsg:"Operation reached timeout: wallets:rpc"})}handleEmbeddedWalletMessages(a){if(!a.event.startsWith("privy:"))return void console.warn(`Unsupported event type: ${a.event}`);let{reject:b,resolve:c}=q.dequeue(a.event,a.id);return void 0!==a.error?b(new i.PrivyIframeError(a.error.type,a.error.message)):c(a.data)}waitForReady(){return this.ready?Promise.resolve():new Promise(async(a,b)=>{for(;!this.ready;)this.invoke("privy:iframe:ready",{}).then(()=>{this.ready=!0,a()}).catch(b),await new Promise(a=>{setTimeout(()=>{a()},150)})})}invoke(a,b){let c=`${a}${JSON.stringify(b,o)}`;if("privy:wallet:create"===a||"privy:solana-wallet:create"===a){let a=this.cache.get(c);if(a)return a}let d=new Promise((c,d)=>{let e=n();q.enqueue(e,{resolve:c,reject:d}),this._embeddedWalletMessagePoster.postMessage(JSON.stringify({id:e,event:a,data:b}),"*")}).finally(()=>{this.cache.delete(c)});return this.cache.set(c,d),d}constructor(a,b){this.ready=!1,this.cache=new Map,this._embeddedWalletMessagePoster=a,this.mfa=b}}var s=a.i(846304),t=a.i(834778),u=a.i(669957);let v={0:"legacy",1:"eip2930",2:"eip1559",3:"eip4844",4:"eip7702"},w={legacy:0,eip2930:1,eip1559:2,eip4844:3,eip7702:4},x=a=>void 0!==a?BigInt(a):void 0;function y(a){let b,{type:c=2,...d}="string"==typeof a?JSON.parse(a):a;d.accessList&&Array.isArray(d.accessList)?b=d.accessList.map(a=>Array.isArray(a)?{address:a[0],storageKeys:a[1]}:a):d.accessList&&(b=Object.entries(d.accessList).map(a=>({address:a[0],storageKeys:a[1]})));let e=Number(d.chainId??1),f=(0,u.isHex)(d.data)?d.data:d.data?(0,t.toHex)(Uint8Array.from(d.data)):void 0,g=d.nonce?Number(d.nonce):void 0,h={chainId:e,data:f,nonce:g,value:x(d.value),gas:x(d.gas??d.gasLimit)},i=Number(c);if(0===i)return{...d,type:v[i],...h,gasPrice:x(d.gasPrice),accessList:void 0,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(1===i)return{...d,type:v[i],...h,gasPrice:x(d.gasPrice),accessList:b,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(2===i)return{...d,type:v[i],...h,nonce:g,accessList:b,maxFeePerGas:x(d.maxFeePerGas),maxPriorityFeePerGas:x(d.maxPriorityFeePerGas),gasPrice:void 0,maxFeePerBlobGas:void 0};throw Error(`Unsupported transaction type: ${c}`)}a.s(["STRING_TO_NUMBER_TXN_TYPE",()=>w,"toViemTransactionSerializable",()=>y],967107);let z=a=>`0x${a.toString("hex")}`;var A=a.i(908046),B=a.i(122500);async function C(a,b){let c=(0,B.default)(b);if(void 0===c)throw new g.PrivyClientError({error:"Failed to prepare the payload for signing",code:"invalid_input"});let d=Buffer.from(c).toString("base64"),{signature:e}=await a({message:d});return{signature:e}}async function D(a,b,{wallet_id:c,...d}){let e={version:1,url:a.getCompiledPath(A.WalletRpc,{params:{wallet_id:c}}),method:A.WalletRpc.method,headers:{"privy-app-id":a.app.appId},body:{...d}},{signature:f}=await C(b,e);return await a.fetchPrivyRoute(A.WalletRpc,{body:d,params:{wallet_id:c},headers:{"privy-authorization-signature":f}})}function E(a){if("number"==typeof a||"bigint"==typeof a)return`0x${BigInt(a).toString(16)}`;if("string"==typeof a)return/^0x[0-9a-fA-F]*$/.test(a)?a:z(Buffer.from(a,"utf8"))}async function F({context:a,account:b,rpcRequest:c}){switch(c.chainType){case"ethereum":return async function({context:a,account:b,rpcRequest:c}){var d;switch(c.method){case"personal_sign":{let[d]=c.params,e=await D(a,a.signRequest,{chain_type:"ethereum",method:"personal_sign",wallet_id:b.id,params:d.startsWith("0x")?{message:d.slice(2),encoding:"hex"}:{message:d,encoding:"utf-8"}});if("personal_sign"!==e.method)throw Error("Unable to sign message");return{data:e.data.signature}}case"eth_signTransaction":{let[d]=c.params,e=await D(a,a.signRequest,{chain_type:"ethereum",method:"eth_signTransaction",wallet_id:b.id,params:{transaction:{from:d.from,to:d.to??void 0,nonce:E(d.nonce),chain_id:E(d.chainId),data:function(a){if(void 0!==a)return"string"==typeof a?/^0x[0-9a-fA-F]*$/.test(a)?a:z(Buffer.from(a,"utf8")):z(Buffer.from(Uint8Array.from(a)))}(d.data),value:E(d.value),type:d.type,gas_limit:E(d.gasLimit),gas_price:E(d.gasPrice),max_fee_per_gas:E(d.maxFeePerGas),max_priority_fee_per_gas:E(d.maxPriorityFeePerGas)}}});if("eth_signTransaction"!==e.method)throw Error("Unable to sign transaction");return{data:e.data.signed_transaction}}case"eth_signTypedData_v4":{let[,e]=c.params,f=await D(a,a.signRequest,{chain_type:"ethereum",method:c.method,wallet_id:b.id,params:{typed_data:("string"==typeof(d=e)&&(d=JSON.parse(d)),{types:d.types,primary_type:String(d.primaryType),domain:d.domain,message:d.message})}});if("eth_signTypedData_v4"!==f.method)throw Error("Unable to sign typed data");return{data:f.data.signature}}case"eth_sign":{let[,d]=c.params,e=await D(a,a.signRequest,{chain_type:"ethereum",method:"secp256k1_sign",wallet_id:b.id,params:{hash:/^0x[0-9a-fA-F]*$/.test(d)?d:z(Buffer.from(d,"utf8"))}});if("secp256k1_sign"!==e.method)throw Error("Unable to sign message");return{data:e.data.signature}}case"secp256k1_sign":{let[d]=c.params,e=await D(a,a.signRequest,{chain_type:"ethereum",method:"secp256k1_sign",wallet_id:b.id,params:{hash:/^0x[0-9a-fA-F]*$/.test(d)?d:z(Buffer.from(d,"utf8"))}});if("secp256k1_sign"!==e.method)throw Error("Unable to sign message");return{data:e.data.signature}}case"csw_signUserOperation":case"eth_sendTransaction":case"eth_populateTransactionRequest":throw Error(`This wallet does not support the method: ${c.method}`)}}({context:a,account:b,rpcRequest:c.request});case"solana":return async function({context:a,account:b,rpcRequest:c}){if("signMessage"===c.method){let{message:d}=c.params,e=await D(a,a.signRequest,{chain_type:"solana",method:"signMessage",wallet_id:b.id,params:{message:d,encoding:"base64"}});if("signMessage"!==e.method)throw Error("Unable to sign message");return{data:e.data.signature}}}({context:a,account:b,rpcRequest:c.request})}}a.s(["generateAuthorizationSignature",()=>C],760331),a.s(["rpc",()=>D],620253);let G=new Set(["eth_sign","personal_sign","eth_signTypedData_v4","csw_signUserOperation","secp256k1_sign"]);class H extends s.default{async request(a){if(G.has(a.method))return this.handleIFrameRpc(a);switch(a.method){case"eth_accounts":case"eth_requestAccounts":return this._account.address?[this._account.address]:[];case"eth_chainId":return`0x${this._chainId.toString(16)}`;case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(a);case"eth_estimateGas":return this.handleEstimateGas(a);case"eth_signTransaction":{let b=a.params?.[0];return this.handleSignTransaction(b)}case"eth_sendTransaction":{let b=a.params?.[0];return this.handleSendTransaction(b)}case"eth_populateTransactionRequest":{let b=a.params?.[0];return this.handlePopulateTransaction(b)}default:return this.handleJsonRpc(a)}}ensureChainId(a){let b={chainId:this._chainId,...a};return this.internalSwitchEthereumChain(b.chainId),b}internalSwitchEthereumChain(a){a&&Number(a)!==this._chainId&&(this._chainId=Number(a),this._client=(0,k.getPublicClient)(this._chainId,this._chains,{rpcUrls:[]},{appId:this._privyInternal.appId}),this.emit("chainChanged",a))}async handlePopulateTransaction(a){let b=this.ensureChainId(a),c=y(b),{type:d,...e}=await this._client.prepareTransactionRequest({account:b.from??this._account.address,...c});return{...e,type:w[d]}}async handleSignTransaction(a){let b={...a};for(let a of Object.keys(b)){let c=b[a];c&&"bigint"==typeof c&&(b[a]=(0,t.toHex)(c))}return await this.handleIFrameRpc({method:"eth_signTransaction",params:[b]})}async handleSendTransaction(a){let b=await this.handlePopulateTransaction(a),c=await this.handleSignTransaction(b);return await this.handleJsonRpc({method:"eth_sendRawTransaction",params:[c]})}async handleEstimateGas(a){if(!a.params||!Array.isArray(a.params))throw Error("Invalid params for eth_estimateGas");let b=a.params?.[0],c=this.ensureChainId(b),d=y(c);return await this._client.estimateGas({account:c.from??this._account.address,...d})}handleSwitchEthereumChain(a){let b;if(!a.params||!Array.isArray(a.params))throw new i.EmbeddedProviderError(`Invalid params for ${a.method}`,4200);if("string"==typeof a.params[0])b=a.params[0];else{if(!("chainId"in a.params[0])||"string"!=typeof a.params[0].chainId)throw new i.EmbeddedProviderError(`Invalid params for ${a.method}`,4200);b=a.params[0].chainId}this.internalSwitchEthereumChain(b)}async handleIFrameRpc(a){try{let b=await this._privyInternal.getAccessTokenInternal();if(!b)throw Error("Missing privy token. User must be logged in");this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:a.method,address:this._account.address});let c=this._account;if((0,l.isUnifiedWallet)(c)){let{data:d}=await F({context:{app:this._appApi,fetchPrivyRoute:(...a)=>this._privyInternal.fetch(...a),getCompiledPath:(...a)=>this._privyInternal.getPath(...a),signRequest:({message:a})=>this._walletProxy.signWithUserSigner({accessToken:b,message:a})},account:c,rpcRequest:{chainType:"ethereum",request:a}});return d}try{await this._walletProxy.connect({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:b})}catch(c){let a=(0,i.errorIndicatesRecoveryIsNeeded)(c);if(a&&"privy"===this._account.recovery_method)await this._walletProxy.recover({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:b});else{if(!a||!this._onNeedsRecovery)throw c;{let a;await new Promise(async(b,c)=>{a=setTimeout(()=>c(new g.PrivyClientError({code:"embedded_wallet_recovery_error",error:"User-owned recovery timed out"})),12e4),await this._onNeedsRecovery?.({recoveryMethod:this._account.recovery_method,onRecovered:()=>b(!0)})}).finally(()=>clearTimeout(a))}}}return(await this._walletProxy.rpcWallet({accessToken:b,request:a,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,hdWalletIndex:this._account.wallet_index,chainType:"ethereum"})).response.data}catch(c){console.error(c);let b=c instanceof Error?c.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:a.method,address:this._account.address,error:b}),new g.PrivyClientError({code:"embedded_wallet_request_error",error:b})}}async handleJsonRpc(a){return this._client.request(a)}toJSON(){return`PrivyEIP1193Provider { address: '${this._account.address}', chainId: ${this._chainId}, request: [Function] }`}constructor({walletProxy:a,privyInternal:b,account:c,entropyId:d,entropyIdVerifier:e,chains:f,onNeedsRecovery:g,chainId:h=f[0].id,appApi:i}){super(),this._walletProxy=a,this._privyInternal=b,this._account=c,this._entropyId=d,this._entropyIdVerifier=e,this._chainId=h,this._chains=f,this._onNeedsRecovery=g,this._client=(0,k.getPublicClient)(h,f,{rpcUrls:[]},{appId:i.appId}),this._appApi=i}}function I(a){return"version"in a}function J(a,b){let c=(I(a)?a.message:a.compileMessage()).staticAccountKeys.find(a=>a.toBase58()===b);if(!c)throw Error(`Transaction does not contain public key ${b}`);return c}class K{async request(a){if(!await this._privyInternal.getAccessTokenInternal())throw new g.PrivyClientError({error:"Missing access token",code:"attempted_rpc_call_before_logged_in"});switch(a.method){case"signAndSendTransaction":return await this.handleSignAndSendTransaction(a);case"signTransaction":return await this.handleSignTransaction(a);default:return await this.handleIFrameRpc(a)}}get _publicKey(){return this._account.address}async connectAndRecover(a){if("privy-v2"!==this._account.recovery_method)try{await this._proxy.connect({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:a})}catch(c){let b=(0,i.errorIndicatesRecoveryIsNeeded)(c);if(b&&"privy"===this._account.recovery_method)await this._proxy.recover({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:a});else{if(!b||!this._onNeedsRecovery)throw c;{let a;await new Promise(async(b,c)=>{a=setTimeout(()=>c(new g.PrivyClientError({code:"embedded_wallet_recovery_error",error:"User-owned recovery timed out"})),12e4),await this._onNeedsRecovery?.({recoveryMethod:this._account.recovery_method,onRecovered:()=>b(!0)})}).finally(()=>clearTimeout(a))}}}}async signMessageRpc(a,b){let c=this._account;if(!(0,l.isUnifiedWallet)(c))return(await this._proxy.rpcWallet({accessToken:b,request:a,chainType:"solana",hdWalletIndex:this._account.wallet_index,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier})).response.data;{let{data:d}=await F({context:{app:this._app,fetchPrivyRoute:(...a)=>this._privyInternal.fetch(...a),getCompiledPath:(...a)=>this._privyInternal.getPath(...a),signRequest:({message:a})=>this._proxy.signWithUserSigner({accessToken:b,message:a})},account:c,rpcRequest:{chainType:"solana",request:a}});return{signature:d}}}async handleIFrameRpc(a){try{let b=await this._privyInternal.getAccessTokenInternal();if(!b)throw Error("Missing privy token. User must be logged in");return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:a.method,address:this._account.address}),await this.connectAndRecover(b),await this.signMessageRpc(a,b)}catch(c){console.error(c);let b=c instanceof Error?c.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:a.method,address:this._account.address,error:b}),new g.PrivyClientError({code:"embedded_wallet_request_error",error:b})}}async handleSignAndSendTransaction(a){try{let b=await this._privyInternal.getAccessTokenInternal();if(!b)throw Error("Missing privy token. User must be logged in");this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:a.method,address:this._account.address}),await this.connectAndRecover(b);let{transaction:c,connection:d,options:e}=a.params,f=J(c,this._account.address),g=I(c)?Buffer.from(c.message.serialize()):c.serializeMessage(),{signature:h}=await this.signMessageRpc({method:"signMessage",params:{message:g.toString("base64")}},b);return c.addSignature(f,Buffer.from(h,"base64")),{signature:await d.sendRawTransaction(c.serialize(),e)}}catch(c){console.error(c);let b=c instanceof Error?c.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:a.method,address:this._account.address,error:b}),new g.PrivyClientError({code:"embedded_wallet_request_error",error:b})}}async handleSignTransaction(a){try{let b=await this._privyInternal.getAccessTokenInternal();if(!b)throw Error("Missing privy token. User must be logged in");this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:a.method,address:this._account.address}),await this.connectAndRecover(b);let{transaction:c}=a.params,d=J(c,this._account.address),e=I(c)?Buffer.from(c.message.serialize()):c.serializeMessage(),{signature:f}=await this.signMessageRpc({method:"signMessage",params:{message:e.toString("base64")}},b);return c.addSignature(d,Buffer.from(f,"base64")),{signedTransaction:c}}catch(c){console.error(c);let b=c instanceof Error?c.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:a.method,address:this._account.wallet_index,error:b}),new g.PrivyClientError({code:"embedded_wallet_request_error",error:b})}}toJSON(){return`PrivyEmbeddedSolanaProvider { address: '${this._account.address}', request: [Function] }`}constructor({proxy:a,privyInternal:b,account:c,entropyId:d,entropyIdVerifier:e,onNeedsRecovery:f,app:g}){this._proxy=a,this._privyInternal=b,this._account=c,this._entropyId=d,this._entropyIdVerifier=e,this._onNeedsRecovery=f,this._app=g}}class L{setMessagePoster(a){this._proxy=new r(a,this._mfaPromises),this._mfa.setProxy(this._proxy)}async signWithUserSigner(a){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");let b=await this._privyInternal.getAccessTokenInternal();if(!b)throw new g.PrivyClientError({error:"User must be logged in to sign a message with the user signer",code:"user_signer_sign_error"});let{signature:c}=await this._proxy.signWithUserSigner({accessToken:b,message:a.message});return{signature:c}}async add(a){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");if("user-controlled-server-wallets-only"===this._privyInternal.config?.embedded_wallet_config.mode)await (0,j.walletCreate)({context:{app:this._appApi,fetchPrivyRoute:(...a)=>this._privyInternal.fetch(...a),getCompiledPath:(...a)=>this._privyInternal.getPath(...a)},chainType:a.chainType});else{let b=await this._privyInternal.getAccessTokenInternal();if(!b)throw new g.PrivyClientError({error:"User must be logged in to create an embedded wallet",code:"embedded_wallet_creation_error"});await this._proxy.addWallet({accessToken:b,...a})}let{user:b}=await this._privyInternal.refreshSession();return{user:b}}async getBitcoinProvider({wallet:a,entropyId:b,entropyIdVerifier:c,recoveryPassword:d,recoveryAccessToken:e,recoverySecretOverride:f}){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");if(!await this._privyInternal.getAccessTokenInternal())throw Error("User must be logged in to create an embedded wallet");return(0,l.isUnifiedWallet)(a)||await this._load({entropyId:b,entropyIdVerifier:c,wallet:a,recoveryPassword:d,recoveryAccessToken:e,recoverySecretOverride:f}),new h.EmbeddedBitcoinWalletProvider({account:a,privyInternal:this._privyInternal,proxy:this._proxy,entropyId:b,entropyIdVerifier:c})}async create({password:a,recoveryMethod:b,recoveryToken:c,recoveryKey:d,recoverySecretOverride:e,iCloudRecordNameOverride:f,solanaAccount:h,skipCallbacks:i}){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");if("user-controlled-server-wallets-only"===this._privyInternal.config?.embedded_wallet_config.mode){if(b&&!b.startsWith("privy"))throw new g.PrivyClientError({error:"User-controlled server wallets do not support custom recovery methods",code:"embedded_wallet_creation_error"});await (0,j.walletCreate)({context:{app:this._appApi,fetchPrivyRoute:(...a)=>this._privyInternal.fetch(...a),getCompiledPath:(...a)=>this._privyInternal.getPath(...a)},chainType:"ethereum"})}else{let g;if(g=b||(a?"user-passcode":"privy"),a&&"string"!=typeof a)throw Error("Invalid recovery password, must be a string");if("privy"===g&&this._privyInternal.config?.embedded_wallet_config.require_user_password_on_create)throw Error("Password not provided yet is required by App configuration");let i=await this._privyInternal.getAccessTokenInternal();if(!i)throw Error("User must be logged in to create an embedded wallet");let{address:j}=await this._proxy.create({accessToken:i,recoveryMethod:g,recoveryKey:d,recoveryPassword:a,recoveryAccessToken:c,recoverySecretOverride:e,iCloudRecordNameOverride:f,solanaAddress:h?.address});if(!j)throw Error("Failed to create wallet")}return await this._privyInternal.refreshSession(i)}async createSolana(a){if(!this._proxy)throw new g.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_creation_error"});if("user-controlled-server-wallets-only"===this._privyInternal.config?.embedded_wallet_config.mode)await (0,j.walletCreate)({context:{app:this._appApi,fetchPrivyRoute:(...a)=>this._privyInternal.fetch(...a),getCompiledPath:(...a)=>this._privyInternal.getPath(...a)},chainType:"solana"});else{let b=await this._privyInternal.getAccessTokenInternal();if(!b)throw new g.PrivyClientError({error:"User must be logged in to create an embedded wallet",code:"embedded_wallet_creation_error"});a?.ethereumAccount&&await this.getProvider(a.ethereumAccount);let{publicKey:c}=await this._proxy.createSolana({accessToken:b,ethereumAddress:a?.ethereumAccount?.address});if(!c)throw new g.PrivyClientError({error:"Failed to create wallet",code:"embedded_wallet_creation_error"})}return await this._privyInternal.refreshSession()}async delegateWallets({delegatedWallets:a,rootWallet:b}){if(!this._proxy)throw new g.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_creation_error"});let c=await this._privyInternal.getAccessTokenInternal();if(!c)throw new g.PrivyClientError({error:"User must be logged in to create an embedded wallet",code:"embedded_wallet_creation_error"});await this._proxy.delegateWallets({accessToken:c,delegatedWallets:a,rootWallet:b})}async getProvider(a,b,c,d,e){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");return(0,l.isUnifiedWallet)(a)||await this._load({wallet:a,entropyId:a.address,entropyIdVerifier:"ethereum-address-verifier",recoveryPassword:b,recoveryKey:e,recoveryAccessToken:c,recoverySecretOverride:d}),new H({account:a,entropyId:a.address,entropyIdVerifier:"ethereum-address-verifier",privyInternal:this._privyInternal,chains:this._chains,walletProxy:this._proxy,appApi:this._appApi})}async getEthereumProvider({wallet:a,entropyId:b,entropyIdVerifier:c,recoveryPassword:d,recoveryAccessToken:e,recoverySecretOverride:f,recoveryKey:g,onNeedsRecovery:h}){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");if(!await this._privyInternal.getAccessTokenInternal())throw Error("User must be logged in to create an embedded wallet");return(0,l.isUnifiedWallet)(a)||(!h||d||e||f||g)&&await this._load({entropyId:b,entropyIdVerifier:c,wallet:a,recoveryPassword:d,recoveryAccessToken:e,recoverySecretOverride:f,recoveryKey:g}),new H({account:a,entropyId:b,entropyIdVerifier:"ethereum-address-verifier",privyInternal:this._privyInternal,chains:this._chains,walletProxy:this._proxy,onNeedsRecovery:h,appApi:this._appApi})}async getSolanaProvider(a,b,c,d,e,f,h){if(!this._proxy)throw new g.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_webview_not_loaded"});return(0,l.isUnifiedWallet)(a)||(!h||d||e||f)&&await this._load({wallet:a,entropyId:b,entropyIdVerifier:c,recoveryPassword:d,recoveryAccessToken:e,recoverySecretOverride:f}),new K({account:a,privyInternal:this._privyInternal,proxy:this._proxy,entropyId:b,entropyIdVerifier:c,onNeedsRecovery:h,app:this._appApi})}async setRecovery(a){let{wallet:b,...c}=a;if(!this._proxy)throw Error("Embedded wallet proxy not initialized");if((0,l.isUnifiedWallet)(b))throw new g.PrivyClientError({error:"This wallet does not support setting recovery methods",code:"unsupported_recovery_method"});(0,k.throwIfInvalidRecoveryUpgradePath)({currentRecoveryMethod:b.recovery_method,upgradeToRecoveryMethod:"icloud-native"===c.recoveryMethod?"icloud":c.recoveryMethod}),await this._load("solana"===b.chain_type?{wallet:b,entropyId:b.address,entropyIdVerifier:"solana-address-verifier"}:{wallet:b,entropyId:b.address,entropyIdVerifier:"ethereum-address-verifier"});let d=await this._privyInternal.getAccessTokenInternal();if(!d)throw Error("User must be logged in to interact with embedded wallets");let e=b.recovery_method;this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_set_recovery_started",{address:b.address,target_recovery_method:c.recoveryMethod,existing_recovery_method:e});try{let a;if("user-passcode"===c.recoveryMethod)a={recoveryMethod:"user-passcode",recoveryPassword:c.password};else if("google-drive"===c.recoveryMethod)a={recoveryMethod:"google-drive",recoveryAccessToken:c.recoveryAccessToken};else if("icloud"===c.recoveryMethod)a={recoveryMethod:"icloud",recoveryAccessToken:c.recoveryAccessToken};else if("icloud-native"===c.recoveryMethod)a={recoveryMethod:"icloud-native",iCloudRecordNameOverride:c.iCloudRecordNameOverride,recoverySecretOverride:c.recoverySecretOverride};else if("recovery-encryption-key"===c.recoveryMethod)a={recoveryMethod:"recovery-encryption-key",recoveryKey:c.recoveryKey};else{if("privy"!==c.recoveryMethod)throw Error(`Unknown recovery method: ${c.recoveryMethod}`);a={recoveryMethod:"privy"}}await this._proxy.setRecovery({accessToken:d,entropyId:b.address,entropyIdVerifier:"solana"===b.chain_type?"solana-address-verifier":"ethereum-address-verifier",...a}),this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_set_recovery_completed",{address:b.address,target_recovery_method:c.recoveryMethod,existing_recovery_method:e});let{user:f}=await this._privyInternal.refreshSession();return{user:f,provider:"ethereum"!==b.chain_type?null:new H({account:b,entropyId:b.address,entropyIdVerifier:"ethereum-address-verifier",privyInternal:this._privyInternal,chains:this._chains,walletProxy:this._proxy,appApi:this._appApi})}}catch(a){throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_set_recovery_failed",{address:b.address,recovery_method:b.recovery_method,error:a instanceof Error?a.message:"Unable to recover wallet"}),a}}getURL(){let a=new URL(`${this._privyInternal.baseUrl}/apps/${this._privyInternal.appId}/embedded-wallets`);return this._privyInternal.caid&&a.searchParams.append("caid",this._privyInternal.caid),this._privyInternal.appClientId&&a.searchParams.append("client_id",this._privyInternal.appClientId),a.href}get chains(){return this._chains}onMessage(a){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");return this._proxy.handleEmbeddedWalletMessages(a)}reload(){this._proxy?this._proxy.reload():console.warn("Attempted to reload proxy before initialized")}async ping(a){try{if(!this._proxy)throw Error("Embedded wallet proxy not initialized");return await this._proxy.ping(a),!0}catch(a){return console.error(a),!1}}async _load({entropyId:a,entropyIdVerifier:b,wallet:c,recoveryPassword:d,recoveryKey:e,recoveryAccessToken:f,recoverySecretOverride:g}){if(!this._proxy)throw Error("Embedded wallet proxy not initialized");let h=await this._privyInternal.getAccessTokenInternal();if(!h)throw Error("User must be logged in to interact with embedded wallets");try{return await this._proxy.connect({accessToken:h,entropyId:a,entropyIdVerifier:b}),a}catch(j){if((0,i.errorIndicatesRecoveryIsNeeded)(j))try{if("privy"===c.recovery_method){this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started",{address:c.address,recovery_method:c.recovery_method});let d=await this._proxy.recover({accessToken:h,entropyId:a,entropyIdVerifier:b});return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed",{address:c.address,recovery_method:c.recovery_method}),d.entropyId}if("user-passcode"===c.recovery_method&&d){this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started",{address:c.address,recovery_method:c.recovery_method});let e=await this._proxy.recover({accessToken:h,recoveryPassword:d,entropyId:a,entropyIdVerifier:b});return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed",{address:c.address,recovery_method:c.recovery_method}),e.entropyId}if(["google-drive","icloud"].includes(c.recovery_method)&&f){this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started",{address:c.address,recovery_method:c.recovery_method});let d=await this._proxy.recover({accessToken:h,recoveryAccessToken:f,entropyId:a,entropyIdVerifier:b});return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed",{address:c.address,recovery_method:c.recovery_method}),d.entropyId}if("icloud"===c.recovery_method&&g){this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started",{address:c.address,recovery_method:"icloud-native"});let d=await this._proxy.recover({accessToken:h,recoverySecretOverride:g,entropyId:a,entropyIdVerifier:b});return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed",{address:c.address,recovery_method:"icloud-native"}),d.entropyId}if("recovery-encryption-key"===c.recovery_method&&e){this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started",{address:c.address,recovery_method:c.recovery_method});let d=await this._proxy.recover({accessToken:h,recoveryKey:e,entropyId:a,entropyIdVerifier:b});return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed",{address:c.address,recovery_method:c.recovery_method}),d.entropyId}}catch(b){throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_failed",{address:c.address,recovery_method:c.recovery_method,error:b instanceof Error?b.message:`Unable to recover wallet: ${a}`}),b}throw j}}constructor(a,b,c,d,g,h){if(this._chains=Array.from(e.DEFAULT_SUPPORTED_CHAINS),this._privyInternal=a,b&&(this._proxy=new r(b,g),d.setProxy(this._proxy)),c){let a=(0,f.dedupeSupportedChains)(c);this._chains=a}this._mfa=d,this._mfaPromises=g,this._appApi=h}}var M=s;class N extends M.default{constructor(){super(),this.rootPromise={current:null},this.submitPromise={current:null}}}var O=a.i(248055),P=a.i(254799);let Q=new Uint8Array(256),R=Q.length,S=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i,T=[];for(let a=0;a<256;++a)T.push((a+256).toString(16).substr(1));let U=function(a,b=0){let c=(T[a[b+0]]+T[a[b+1]]+T[a[b+2]]+T[a[b+3]]+"-"+T[a[b+4]]+T[a[b+5]]+"-"+T[a[b+6]]+T[a[b+7]]+"-"+T[a[b+8]]+T[a[b+9]]+"-"+T[a[b+10]]+T[a[b+11]]+T[a[b+12]]+T[a[b+13]]+T[a[b+14]]+T[a[b+15]]).toLowerCase();if(!("string"==typeof c&&S.test(c)))throw TypeError("Stringified UUID is invalid");return c},V=function(a,b,c){let d=(a=a||{}).random||(a.rng||function(){return R>Q.length-16&&(P.default.randomFillSync(Q),R=0),Q.slice(R,R+=16)})();if(d[6]=15&d[6]|64,d[8]=63&d[8]|128,b){c=c||0;for(let a=0;a<16;++a)b[c+a]=d[a];return b}return U(d)};a.s(["v4",0,V],178825);var W,X,Y=((X={}).OAUTH_ACCOUNT_SUSPENDED="oauth_account_suspended",X.MISSING_OR_INVALID_PRIVY_APP_ID="missing_or_invalid_privy_app_id",X.MISSING_OR_INVALID_PRIVY_CLIENT_ID="missing_or_invalid_privy_client_id",X.MISSING_OR_INVALID_PRIVY_ACCOUNT_ID="missing_or_invalid_privy_account_id",X.MISSING_OR_INVALID_TOKEN="missing_or_invalid_token",X.MISSING_MFA_ENROLLMENT="missing_mfa_enrollment",X.MISSING_OR_INVALID_MFA="missing_or_invalid_mfa",X.EXPIRED_OR_INVALID_MFA_TOKEN="expired_or_invalid_mfa_token",X.INVALID_DATA="invalid_data",X.INVALID_CREDENTIALS="invalid_credentials",X.INVALID_CAPTCHA="invalid_captcha",X.LINKED_TO_ANOTHER_USER="linked_to_another_user",X.ALLOWLIST_REJECTED="allowlist_rejected",X.CANNOT_UNLINK_EMBEDDED_WALLET="cannot_unlink_embedded_wallet",X.CANNOT_UNLINK_SOLE_ACCOUNT="cannot_unlink_sole_account",X.CANNOT_LINK_MORE_OF_TYPE="cannot_link_more_of_type",X.LINKED_ACCOUNT_NOT_FOUND="linked_account_not_found",X.TOO_MANY_REQUESTS="too_many_requests",X.RESOURCE_CONFLICT="resource_conflict",X.INVALID_ORIGIN="invalid_origin",X.MISSING_ORIGIN="missing_origin",X.INVALID_NATIVE_APP_ID="invalid_native_app_id",X.TOKEN_ALREADY_USED="token_already_used",X.ALREADY_LOGGED_OUT="already_logged_out",X.NOT_SUPPORTED="not_supported",X.USER_UNSUBSCRIBED="user_unsubscribed",X.MAX_APPS_REACHED="max_apps_reached",X.USER_LIMIT_REACHED="max_accounts_reached",X.DEVICE_REVOKED="device_revoked",X.WALLET_PASSWORD_EXISTS="wallet_password_exists",X.OAUTH_STATE_MISMATCH="oauth_state_mismatch",X.MAX_DENYLIST_ENTRIES_REACHED="max_denylist_entries_reached",X.MAX_TEST_ACCOUNTS_REACHED="max_test_accounts_reached",X.DISALLOWED_LOGIN_METHOD="disallowed_login_method",X.DISALLOWED_PLUS_EMAIL="disallowed_plus_email",X.DISALLOWED_RECOVERY_METHOD="disallowed_recovery_method",X.LEGACY_DASHBOARD_LOGIN_CONFIGURATION="legacy_dashboard_login_configuration",X.CANNOT_SET_PASSWORD="cannot_set_password",X.INVALID_PKCE_PARAMETERS="invalid_pkce_parameters",X.INVALID_APP_URL_SCHEME_CONFIGURATION="invalid_app_url_scheme_configuration",X.CROSS_APP_CONNECTION_NOT_ALLOWED="cross_app_connection_not_allowed",X.USER_DOES_NOT_EXIST="user_does_not_exist",X.ALREADY_EXISTS="resource_already_exists",X.ACCOUNT_TRANSFER_REQUIRED="account_transfer_required",X.USER_HAS_NOT_DELEGATED_WALLET="user_has_not_delegated_wallet",X.FEATURE_NOT_ENABLED="feature_not_enabled",X.INSUFFICIENT_FUNDS="insufficient_funds",X.TRANSACTION_BROADCAST_FAILURE="transaction_broadcast_failure",X.TRANSACTION_EXECUTION_FAILURE="transaction_execution_failure",X.INVALID_POLICY_FORMAT="invalid_policy_format",X.POLICY_VIOLATION="policy_violation",X.AUTHORIZATION_KEY_HAS_ASSOCIATED_WALLETS="authorization_key_has_associated_wallets",X.INVALID_REQUEST="invalid_request",X.SIGNUP_DISABLED="signup_disabled",X);a.s(["PrivyErrorCode",()=>Y],389337);let Z={path:"/api/v1/apps/:app_id",method:"GET"},$={path:"/api/v1/analytics_events",method:"POST"},_={path:"/api/v1/sessions",method:"POST"},aa={path:"/api/v1/sessions/logout",method:"POST"};var ab=s,ac=a.i(475231),ac=ac;function ad(a){for(var b=1;b<arguments.length;b++){var c=arguments[b];for(var d in c)a[d]=c[d]}return a}var ae=function a(b,c){function d(a,d,e){if("undefined"!=typeof document){"number"==typeof(e=ad({},c,e)).expires&&(e.expires=new Date(Date.now()+864e5*e.expires)),e.expires&&(e.expires=e.expires.toUTCString()),a=encodeURIComponent(a).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape);var f="";for(var g in e)e[g]&&(f+="; "+g,!0!==e[g]&&(f+="="+e[g].split(";")[0]));return document.cookie=a+"="+b.write(d,a)+f}}return Object.create({set:d,get:function(a){if("undefined"!=typeof document&&(!arguments.length||a)){for(var c=document.cookie?document.cookie.split("; "):[],d={},e=0;e<c.length;e++){var f=c[e].split("="),g=f.slice(1).join("=");try{var h=decodeURIComponent(f[0]);if(d[h]=b.read(g,h),a===h)break}catch(a){}}return a?d[a]:d}},remove:function(a,b){d(a,"",ad({},b,{expires:-1}))},withAttributes:function(b){return a(this.converter,ad({},this.attributes,b))},withConverter:function(b){return a(ad({},this.converter,b),this.attributes)}},{attributes:{value:Object.freeze(c)},converter:{value:Object.freeze(b)}})}({read:function(a){return'"'===a[0]&&(a=a.slice(1,-1)),a.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent)},write:function(a){return encodeURIComponent(a).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,decodeURIComponent)}},{path:"/"});a.s(["default",()=>ae],814465);var af=a.i(370147);let ag=Promise.allSettled.bind(Promise)??(a=>Promise.all(a.map(a=>a.then(a=>({status:"fulfilled",value:a})).catch(a=>({status:"rejected",reason:a}))))),ah="privy:token",ai="privy-token",aj="privy:pat",ak="privy:refresh_token",al="privy-refresh-token",am="privy:id-token",an="privy-id-token",ao="privy-session";class ap extends ab.default{set isUsingServerCookies(a){this._isUsingServerCookies=a}async getCustomerAccessToken(){let a=await this._storage.get(ah);try{return"string"==typeof a?new af.Token(a).value:null}catch(a){return console.error(a),await this.destroyLocalState({reason:"getToken_error"}),null}}async getPrivyAccessToken(){let a=await this._storage.get(aj);try{return"string"==typeof a?new af.Token(a).value:null}catch(a){return console.error(a),await this.destroyLocalState({reason:"getToken_error"}),null}}async getRefreshToken(){let a=await this._storage.get(ak);return"string"==typeof a?a:null}async getIdentityToken(){let a=await this._storage.get(am);return"string"==typeof a?a:null}get mightHaveServerCookies(){try{let a=ae.get(ao);return void 0!==a&&a.length>0}catch(a){console.error(a)}return!1}hasRefreshCredentials(a,b){return this.mightHaveServerCookies||"string"==typeof a&&"string"==typeof b}tokenIsActive(a){if(!a)return!1;let b=af.Token.parse(a);return null!==b&&!b.isExpired(30)}async destroyLocalState(a){await ag([this._storage.del(ah),this._storage.del(ak),this._storage.del(am),this._storage.del(this.GUEST_CREDENTIAL_STORAGE_KEY)]),ae.remove(ai),ae.remove(al),ae.remove(an),ae.remove(ao),a?.reason&&this.emit("storage_cleared",{reason:a.reason})}async storeCustomerAccessToken(a){if("string"==typeof a){let b=await this._storage.get(ah);if(await this._storage.put(ah,a),!this._isUsingServerCookies){let b=af.Token.parse(a)?.expiration;ae.set(ai,a,{sameSite:"Strict",secure:!0,expires:b?new Date(1e3*b):void 0})}b!==a&&this.emit("token_stored",{cookiesEnabled:this._isUsingServerCookies})}else{let a=await this._storage.get(ah);await this._storage.del(ah),ae.remove(ai),null!==a&&this.emit("token_cleared",{reason:"set_with_non_string_value"})}}async storePrivyAccessToken(a){"string"==typeof a?await this._storage.put(aj,a):await this._storage.del(aj)}async storeRefreshToken(a){"string"==typeof a?(await this._storage.put(ak,a),this._isUsingServerCookies||(ae.set(ao,"t",{sameSite:"Strict",secure:!0,expires:30}),ae.set(al,a,{sameSite:"Strict",secure:!0,expires:30})),this.emit("refresh_token_stored",{cookiesEnabled:this._isUsingServerCookies})):(await this._storage.del(ak),ae.remove(al),ae.remove(ao),this.emit("refresh_token_cleared",{reason:"set_with_non_string_value"}))}async updateWithTokensResponse(a){let b=(await ag([this.storeCustomerAccessToken(a.token),this.storePrivyAccessToken(a.privy_access_token),this.storeRefreshToken(a.refresh_token),this.storeIdentityToken(a.identity_token),this.processOAuthTokens(a.oauth_tokens)])).filter(a=>"rejected"===a.status);b.length>0&&this.emit("error_storing_tokens",b.map(a=>String(a.reason)).join(", "))}async processOAuthTokens(a){a&&this.emit("oauth_tokens_granted",a)}async storeIdentityToken(a){if("string"==typeof a){let b=await this._storage.get(am);if(await this._storage.put(am,a),!this._isUsingServerCookies){let b=af.Token.parse(a)?.expiration;ae.set(an,a,{sameSite:"Strict",secure:!0,expires:b?new Date(1e3*b):void 0})}b!==a&&this.emit("identity_token_stored",{cookiesEnabled:this._isUsingServerCookies})}else{let a=await this._storage.get(am);await this._storage.del(am),ae.remove(an),null!==a&&this.emit("identity_token_cleared",{reason:"set_with_non_string_value"})}}async getOrCreateGuestCredential(){let a=this._storage.get(this.GUEST_CREDENTIAL_STORAGE_KEY);if(a&&"string"==typeof a)return a;let b=ac.encode(crypto.getRandomValues(new Uint8Array(32)));return await this._storage.put(this.GUEST_CREDENTIAL_STORAGE_KEY,b),b}constructor(a){super(),this._isUsingServerCookies=!1,this._storage=a.storage,this.GUEST_CREDENTIAL_STORAGE_KEY=`privy:guest:${a.appId}`}}ap.events=["storage_cleared","token_cleared","refresh_token_cleared","identity_token_cleared","token_stored","refresh_token_stored","identity_token_stored","oauth_tokens_granted","error_storing_tokens"];let aq=()=>{},ar={NONE:-1/0,ERROR:1,WARN:2,INFO:3,DEBUG:1/0},as="privy:caid";class at{setCallbacks(a){this.callbacks={...this.callbacks,...a}}get isReady(){return!!this._config}get config(){return this._config}get caid(){return this._analyticsId}async _initialize(){if(this.isReady)this.callbacks?.setIsReady?.(!0);else{if(!await this.isStorageAccessible())throw new g.PrivyClientError({code:"storage_error",error:"Unable to access storage"});this._config=await this.getAppConfig(),this._config?.custom_api_url&&(this.baseUrl=this._config.custom_api_url,this.session.isUsingServerCookies=!0),this.callbacks?.setIsReady?.(!0),this._sdkVersion.startsWith("react-auth:")||this.createAnalyticsEvent("sdk_initialize",{})}}getPath(a,{params:b,query:c}){let d;return`${this.baseUrl}${d=a.path,b?Object.entries(b).reduce((a,[b,c])=>a.replace(`:${b}`,`${c}`),d):d}${function(a){let b=new URLSearchParams;for(let c in a)null!=a[c]&&b.append(c,String(a[c]));return Array.from(b).length?"?"+b.toString():""}(c)}`}async fetch(a,{body:b,params:c,query:d,headers:e,onRequest:f=this._beforeRequest.bind(this)}){let h=new Request(this.getPath(a,{params:c,query:d}),{method:a.method,body:JSON.stringify(b),headers:e}),i=await f(h),j=await this._fetch(h,i),k=await j.json();if(j.status>299)throw new g.PrivyApiError(k);return k}async _beforeRequestWithoutInitialize(a){let b,c=await this.session.getPrivyAccessToken()??await this.session.getCustomerAccessToken(),d=new Headers(a.headers);d.set("privy-app-id",this.appId),this.appClientId&&d.set("privy-client-id",this.appClientId),d.set("privy-client",this._sdkVersion),c&&d.set("Authorization",`Bearer ${c}`),d.set("Content-Type","application/json"),d.set("Accept","application/json");let e=await this._getOrGenerateClientAnalyticsId();return e&&d.set("privy-ca-id",e),this.nativeAppIdentifier&&d.set("x-native-app-identifier",this.nativeAppIdentifier),{signal:(b=new AbortController,setTimeout(()=>b.abort(),2e4),b.signal),headers:d,credentials:"include"}}async beforeRequestWithoutRefresh(a){return await this._initialize(),this._beforeRequestWithoutInitialize(a)}async _beforeRequest(a){return await this._initialize(),await this.getAccessTokenInternal(),this.beforeRequestWithoutRefresh(a)}async getAppConfig(){return await this.fetch(Z,{params:{app_id:this.appId},onRequest:this._beforeRequestWithoutInitialize.bind(this)})}async _getOrGenerateClientAnalyticsId(){if(this._analyticsId)return this._analyticsId;try{let a=await this._storage.get(as);if("string"==typeof a&&a.length>0)return this._analyticsId=a,a}catch(a){this.logger.error("Unable to load clientId",a)}try{this._analyticsId=V()}catch(a){this.logger.error("Unable to generate uuidv4",a)}if(this._analyticsId){try{await this._storage.put(as,this._analyticsId)}catch(a){this.logger.error(`Unable to store clientId: ${this._analyticsId}`,a)}return this._analyticsId}}async destroyClientAnalyticsId(){try{return await this._storage.del(as)}catch(a){this.logger.error("Unable to delete clientId",a)}}async createAnalyticsEvent(a,b){try{await this.fetch($,{body:{event_name:a,client_id:await this._getOrGenerateClientAnalyticsId(),payload:b},onRequest:this.beforeRequestWithoutRefresh.bind(this)})}catch(a){}}async refreshSession(a=!1){if(!await this.isStorageAccessible())throw new g.PrivyClientError({code:"storage_error",error:"Unable to access storage"});let b=await this.session.getRefreshToken()??void 0,c=b??"key",d=this._cache.get(c);if(d)return this.logger.debug("[privy:refresh] found in-flight session refresh request, deduping"),await d;let e=this._refreshSession(b,a);this._cache.set(c,e);try{return await e}finally{this._cache.delete(c)}}async _refreshSession(a,b){let c=await this.session.getCustomerAccessToken();if(!this.session.hasRefreshCredentials(c,a??null))throw this.logger.debug("[privy:refresh] missing tokens, skipping request"),await this._initialize(),new g.PrivyApiError({code:Y.MISSING_OR_INVALID_TOKEN,error:"No tokens found in storage"});try{this.logger.debug(`[privy:refresh] fetching: ${_.path}`);let c=await this.fetch(_,{body:{refresh_token:a},onRequest:this.beforeRequestWithoutRefresh.bind(this)}),d=c.session_update_action;return this.logger.debug(`[privy:refresh] response: ${d}`),b||this.callbacks?.setUser?.(c.user),"set"===d&&(await this.session.updateWithTokensResponse(c),this.logger.debug("[privy:refresh] tokens stored")),"clear"===d&&(await this.session.destroyLocalState(),this.logger.debug("[privy:refresh] tokens cleared"),b||this.callbacks?.setUser?.(null)),"ignore"===d&&c.token&&(await this.session.storeCustomerAccessToken(c.token),await this.session.storePrivyAccessToken(c.privy_access_token),this.logger.debug("[privy:refresh] access token stored"),c.identity_token&&(this.logger.debug("[privy:refresh] identity token stored"),await this.session.storeIdentityToken(c.identity_token))),this.logger.debug("[privy:refresh] returning response"),c}catch(a){throw this.logger.debug(`[privy:refresh] error: ${a.message??"unknown error"}`),a instanceof g.PrivyApiError&&a.code===Y.MISSING_OR_INVALID_TOKEN&&(await this.session.destroyLocalState(),b||this.callbacks?.setUser?.(null)),a}}async getAccessToken(){let[a,b]=await Promise.all([this.session.getCustomerAccessToken(),this.session.getRefreshToken()]);if(!this.session.tokenIsActive(a)&&this.session.hasRefreshCredentials(a,b)){let b=await this.refreshSession(),c=await this.session.getCustomerAccessToken();return b.token||this.logger.debug("[privy:getAccessToken] expected token received null"),b.token===a&&this.logger.debug("[privy:getAccessToken] expected new token in response received existing"),c===a&&this.logger.debug("[privy:getAccessToken] expected new token in storage received existing"),b.token??c}return a}async getAccessTokenInternal(){let a=await this.getAccessToken();return await this.session.getPrivyAccessToken()??a}async getIdentityToken(){return await this.session.getIdentityToken()}async isStorageAccessible(){try{let a=`privy:__storage__test-${V()}`,b="blobby";await this._storage.put(a,b);let c=await this._storage.get(a);return await this._storage.del(a),c===b}catch(a){return this.logger.error(a),!1}}constructor(a){this._sdkVersion="js-sdk-core:0.58.5",this._cache=new Map,this.logger=(({level:a}={level:"ERROR"})=>({get level(){return a},error:ar[a]>=ar.ERROR?console.error:aq,warn:ar[a]>=ar.WARN?console.warn:aq,info:ar[a]>=ar.INFO?console.info:aq,debug:ar[a]>=ar.DEBUG?console.debug:aq}))({level:a.logLevel??"ERROR"}),this._storage=a.storage,this._analyticsId=null,this._getOrGenerateClientAnalyticsId(),this.baseUrl=a.baseUrl??"https://auth.privy.io",this.appId=a.appId,this.appClientId=a.appClientId,this._sdkVersion=a.sdkVersion??this._sdkVersion,this.callbacks=a.callbacks,this.nativeAppIdentifier=a.nativeAppIdentifier,this.session=new ap({storage:this._storage,isUsingServerCookies:!1,appId:a.appId}),this._fetch=(0,O.default)(globalThis.fetch,{retries:3,retryDelay:a=>3**a*500,retryOn:[408,409,425,500,502,503,504]}),this.session.on("error_storing_tokens",a=>{this.createAnalyticsEvent("error_updating_tokens_in_storage",{reason:a})})}}let au={path:"/api/v1/users/me/accept_terms",method:"POST"};class av{async get(){let{user:a}=await this._privyInternal.refreshSession();return{user:a}}async acceptTerms(){return{user:await this._privyInternal.fetch(au,{})}}constructor(a){this._privyInternal=a}}let aw={path:"/api/v1/custom_jwt_account/authenticate",method:"POST"},ax=a=>"wallet"===a.type&&"privy"===a.wallet_client_type&&"embedded"===a.connector_type,ay=a=>a?a.linked_accounts.filter(ax).filter(a=>"ethereum"===a.chain_type).sort((a,b)=>a.wallet_index-b.wallet_index):[],az=a=>ay(a).find(a=>0===a.wallet_index)??null,aA=a=>a?a.linked_accounts.filter(ax).filter(a=>"solana"===a.chain_type).sort((a,b)=>a.wallet_index-b.wallet_index):[],aB=async(a,b,c)=>{let d,e,f,g,h=(d=b.user,!("off"===(e=c?.ethereum?.createOnLogin??"off")||ay(d).length>0||d.linked_accounts.filter(a=>"wallet"===a.type&&"ethereum"===a.chain_type).length>0&&"all-users"!==e)),i=(f=b.user,!("off"===(g=c?.solana?.createOnLogin??"off")||aA(f).length>0||f.linked_accounts.filter(a=>"wallet"===a.type&&"solana"===a.chain_type).length>0&&"all-users"!==g));if(h&&i){let c=await a.create({recoveryMethod:"privy",skipCallbacks:!0});return{...await a.createSolana({ethereumAccount:az(c.user)??void 0}),is_new_user:b.is_new_user,oauth_tokens:b.oauth_tokens}}return h?{...await a.create({recoveryMethod:"privy",solanaAccount:aA(b.user).find(a=>0===a.wallet_index)??null??void 0}),is_new_user:b.is_new_user,oauth_tokens:b.oauth_tokens}:i?{...await a.createSolana({ethereumAccount:az(b.user)??void 0}),is_new_user:b.is_new_user,oauth_tokens:b.oauth_tokens}:b};class aC{async syncWithToken(a,b,c){let d=await this._privyInternal.fetch(aw,{body:{token:a,mode:c}});await this._privyInternal.session.updateWithTokensResponse(d);let e=await aB(this._embedded,d,b?.embedded);return this._privyInternal.callbacks?.setUser?.(e.user),e}constructor(a,b){this._privyInternal=a,this._embedded=b}}let aD={path:"/api/v1/passwordless/authenticate",method:"POST"},aE={path:"/api/v1/passwordless/init",method:"POST"},aF={path:"/api/v1/passwordless/link",method:"POST"},aG={path:"/api/v1/passwordless/unlink",method:"POST"},aH={path:"/api/v1/passwordless/update",method:"POST"};class aI{async sendCode(a,b){return this._privyInternal.fetch(aE,{body:{email:a,token:b}})}async loginWithCode(a,b,c,d){let e=await this._privyInternal.fetch(aD,{body:{email:a,code:b,mode:c}});await this._privyInternal.session.updateWithTokensResponse(e);let f=await aB(this._embedded,e,d?.embedded);return this._privyInternal.callbacks?.setUser?.(f.user),f}async linkWithCode(a,b){await this._privyInternal.fetch(aF,{body:{email:a,code:b}});let c=await this._privyInternal.refreshSession();return{user:c.user,identity_token:c.identity_token}}async updateEmail({oldEmailAddress:a,newEmailAddress:b,code:c}){await this._privyInternal.fetch(aH,{body:{oldAddress:a,newAddress:b,code:c}});let d=await this._privyInternal.refreshSession();return{user:d.user,identity_token:d.identity_token}}async unlink(a){await this._privyInternal.fetch(aG,{body:{address:a}});let b=await this._privyInternal.refreshSession();return{user:b.user,identity_token:b.identity_token}}constructor(a,b){this._privyInternal=a,this._embedded=b}}let aJ={path:"/api/v1/farcaster/init",method:"POST"},aK={path:"/api/v1/farcaster/authenticate",method:"POST"},aL={path:"/api/v1/farcaster/link",method:"POST"},aM={path:"/api/v1/farcaster/unlink",method:"POST"},aN={path:"/api/v1/farcaster/status",method:"GET"},aO={path:"/api/v2/farcaster/init",method:"POST"},aP={path:"/api/v2/farcaster/authenticate",method:"POST"};class aQ{async initializeAuth({relyingParty:a,redirectUrl:b,token:c}){return await this._privyInternal.fetch(aJ,{body:{relying_party:a,redirect_url:b,token:c}})}async getFarcasterStatus({channel_token:a}){return await this._privyInternal.fetch(aN,{headers:{"farcaster-channel-token":a}})}async authenticate({channel_token:a,message:b,signature:c,fid:d,mode:e},f){let g=await this._privyInternal.fetch(aK,{body:{channel_token:a,message:b,signature:c,fid:d,mode:e}});await this._privyInternal.session.updateWithTokensResponse(g);let h=await aB(this._embedded,g,f?.embedded);return this._privyInternal.callbacks?.setUser?.(h.user),h}async link({channel_token:a,message:b,signature:c,fid:d}){await this._privyInternal.fetch(aL,{body:{channel_token:a,message:b,signature:c,fid:d}});let e=await this._privyInternal.refreshSession();return{user:e.user,identity_token:e.identity_token}}async unlink({fid:a}){await this._privyInternal.fetch(aM,{body:{fid:a}});let b=await this._privyInternal.refreshSession();return{user:b.user,identity_token:b.identity_token}}constructor(a,b){this._privyInternal=a,this._embedded=b}}class aR{async initializeAuth(){return await this._privyInternal.fetch(aO,{body:{}})}async authenticate({message:a,signature:b,fid:c},d){let e=await this._privyInternal.fetch(aP,{body:{message:a,signature:b,fid:c}});await this._privyInternal.session.updateWithTokensResponse(e);let f=await aB(this._embedded,e,d?.embedded);return this._privyInternal.callbacks?.setUser?.(f.user),f}constructor(a,b){this._privyInternal=a,this._embedded=b}}let aS={path:"/api/v1/guest/authenticate",method:"POST"};class aT{async create(a){let b=await this._privyInternal.session.getOrCreateGuestCredential(),c=await this._privyInternal.fetch(aS,{body:{guest_credential:b}});await this._privyInternal.session.updateWithTokensResponse(c);let d=await aB(this._embedded,c,a?.embedded);return this._privyInternal.callbacks?.setUser?.(d.user),d}constructor(a,b){this._privyInternal=a,this._embedded=b}}let aU={path:"/api/v1/oauth/authenticate",method:"POST"},aV={path:"/api/v1/oauth/init",method:"POST"},aW={path:"/api/v1/oauth/link",method:"POST"},aX={path:"/api/v1/oauth/unlink",method:"POST"};var ac=ac;let aY="privy:state_code",aZ="privy:code_verifier";async function a$(a,b){let c=(new TextEncoder).encode(a);return new Uint8Array(await b("SHA-256",c))}function a_(){return ac.encode(crypto.getRandomValues(new Uint8Array(36)))}async function a0({codeVerifier:a,method:b="S256",digest:c=crypto.subtle.digest.bind(crypto.subtle)}){if("S256"!=b)return a;{let b=await a$(a,c);return ac.encode(b)}}class a1{async generateURL(a,b){let c=a_(),d=a_(),e=await a0({codeVerifier:c,digest:this._crypto?.digest});return await Promise.all([this._storage.put(aZ,c),this._storage.put(aY,d)]),this._privyInternal.fetch(aV,{body:{redirect_to:b,provider:a,code_challenge:e,state_code:d}})}async loginWithCode(a,b,c,d,e,f){let[h,i]=await Promise.all([this._storage.get(aZ),this._storage.get(aY)]);if(i!==b)throw this._privyInternal.createAnalyticsEvent("possible_phishing_attempt",{flow:"oauth",provider:c,storedStateCode:i??"",returnedStateCode:b??""}),new g.PrivyClientError({code:"pkce_state_code_mismatch",error:"Unexpected auth flow. This may be a phishing attempt."});let j=await this._privyInternal.fetch(aU,{body:{authorization_code:a,code_type:d,state_code:i,code_verifier:h,mode:e}});await this._privyInternal.session.updateWithTokensResponse(j);let k=await aB(this._embedded,j,f?.embedded);return await Promise.all([this._storage.del(aZ),this._storage.del(aY)]),this._privyInternal.callbacks?.setUser?.(k.user),k}async linkWithCode(a,b,c,d){let[e,f]=await Promise.all([this._storage.get(aZ),this._storage.get(aY)]);if(f!==b)throw this._privyInternal.createAnalyticsEvent("possible_phishing_attempt",{flow:"oauth",provider:c,storedStateCode:f??"",returnedStateCode:b??""}),new g.PrivyClientError({code:"pkce_state_code_mismatch",error:"Unexpected auth flow. This may be a phishing attempt."});let h=await this._privyInternal.fetch(aW,{body:{authorization_code:a,code_type:d,state_code:f,code_verifier:e}});await this._privyInternal.session.processOAuthTokens(h.oauth_tokens);let i=await this._privyInternal.refreshSession();return await Promise.all([this._storage.del(aZ),this._storage.del(aY)]),{user:i.user,identity_token:i.identity_token}}async unlink(a,b){await this._privyInternal.fetch(aX,{body:{provider:a,subject:b}});let c=await this._privyInternal.refreshSession();return{user:c.user,identity_token:c.identity_token}}constructor(a,b,c,d){this._privyInternal=a,this._embedded=b,this._storage=c,this._crypto=d}}let a2={path:"/api/v1/passkeys/link",method:"POST"},a3={path:"/api/v1/passkeys/authenticate",method:"POST"},a4={path:"/api/v1/passkeys/register",method:"POST"},a5={path:"/api/v1/passkeys/authenticate/init",method:"POST"},a6={path:"/api/v1/passkeys/register/init",method:"POST"},a7={path:"/api/v1/passkeys/link/init",method:"POST"};class a8{async generateRegistrationOptions(a){return await this._privyInternal.fetch(a7,{body:{relying_party:a}})}async generateAuthenticationOptions(a){return await this._privyInternal.fetch(a5,{body:{relying_party:a}})}async generateSignupOptions(a){return await this._privyInternal.fetch(a6,{body:{relying_party:a}})}async loginWithPasskey(a,b,c,d){let e=await this._privyInternal.fetch(a3,{body:{relying_party:c,challenge:b,authenticator_response:this._transformAuthenticationResponseToSnakeCase(a)}});await this._privyInternal.session.updateWithTokensResponse(e);let f=await aB(this._embedded,e,d?.embedded);return this._privyInternal.callbacks?.setUser?.(f.user),f}async signupWithPasskey(a,b,c){let d=await this._privyInternal.fetch(a4,{body:{relying_party:b,authenticator_response:this._transformRegistrationResponseToSnakeCase(a)}});await this._privyInternal.session.updateWithTokensResponse(d);let e=await aB(this._embedded,d,c?.embedded);return this._privyInternal.callbacks?.setUser?.(e.user),e}async linkWithPasskey(a,b){await this._privyInternal.fetch(a2,{body:{relying_party:b,authenticator_response:this._transformRegistrationResponseToSnakeCase(a)}});let c=await this._privyInternal.refreshSession();return{user:c.user,identity_token:c.identity_token}}_transformRegistrationResponseToSnakeCase(a){return{type:a.type,id:a.id,raw_id:a.rawId,response:{client_data_json:a.response.clientDataJSON,attestation_object:a.response.attestationObject,authenticator_data:a.response.authenticatorData||void 0,transports:a.response.transports||void 0,public_key:a.response.publicKey||void 0,public_key_algorithm:a.response.publicKeyAlgorithm||void 0},authenticator_attachment:a.authenticatorAttachment||void 0,client_extension_results:{app_id:a.clientExtensionResults.appid||void 0,cred_props:a.clientExtensionResults.credProps||void 0,hmac_create_secret:a.clientExtensionResults.hmacCreateSecret||void 0}}}_transformAuthenticationResponseToSnakeCase(a){return{type:a.type,id:a.id,raw_id:a.rawId,response:{signature:a.response.signature,client_data_json:a.response.clientDataJSON,authenticator_data:a.response.authenticatorData,user_handle:a.response.userHandle||void 0},authenticator_attachment:a.authenticatorAttachment||void 0,client_extension_results:{app_id:a.clientExtensionResults.appid||void 0,cred_props:a.clientExtensionResults.credProps||void 0,hmac_create_secret:a.clientExtensionResults.hmacCreateSecret||void 0}}}constructor(a,b){this._privyInternal=a,this._embedded=b}}let a9={path:"/api/v1/passwordless_sms/authenticate",method:"POST"},ba={path:"/api/v1/passwordless_sms/init",method:"POST"},bb={path:"/api/v1/passwordless_sms/link",method:"POST"},bc={path:"/api/v1/passwordless_sms/unlink",method:"POST"},bd={path:"/api/v1/passwordless_sms/update",method:"POST"};class be{async sendCode(a,b){return this._privyInternal.fetch(ba,{body:{phoneNumber:a,token:b}})}async loginWithCode(a,b,c,d){let e=await this._privyInternal.fetch(a9,{body:{phoneNumber:a,code:b,mode:c}});await this._privyInternal.session.updateWithTokensResponse(e);let f=await aB(this._embedded,e,d?.embedded);return this._privyInternal.callbacks?.setUser?.(f.user),f}async linkWithCode(a,b){await this._privyInternal.fetch(bb,{body:{phoneNumber:a,code:b}});let c=await this._privyInternal.refreshSession();return{user:c.user,identity_token:c.identity_token}}async updatePhone({oldPhoneNumber:a,newPhoneNumber:b,code:c}){await this._privyInternal.fetch(bd,{body:{old_phone_number:a,new_phone_number:b,code:c}});let d=await this._privyInternal.refreshSession();return{user:d.user,identity_token:d.identity_token}}async unlink(a){await this._privyInternal.fetch(bc,{body:{phoneNumber:a}});let b=await this._privyInternal.refreshSession();return{user:b.user,identity_token:b.identity_token}}constructor(a,b){this._privyInternal=a,this._embedded=b}}let bf={path:"/api/v1/siwe/init",method:"POST"},bg={path:"/api/v1/siwe/authenticate",method:"POST"},bh={path:"/api/v1/siwe/link",method:"POST"},bi={path:"/api/v1/siwe/link_smart_wallet",method:"POST"},bj={path:"/api/v1/siwe/unlink",method:"POST"};class bk{async unlinkWallet(a){await this._privyInternal.fetch(bj,{body:{address:a}});let b=await this._privyInternal.refreshSession();return{user:b.user,identity_token:b.identity_token}}async linkWithSiwe(a,b,c){let d=b||this._wallet,e=c||this._preparedMessage;if(!d)throw Error("A wallet must be provided in the init step or as an argument to linkWithSiwe");if(!e)throw Error("A message must be generated and signed before being used to link a wallet to privy");await this._privyInternal.fetch(bh,{body:{message:e,signature:a,chainId:d.chainId,walletClientType:d.walletClientType??null,connectorType:d.connectorType??null}});let f=await this._privyInternal.refreshSession();return{user:f.user,identity_token:f.identity_token}}async loginWithSiwe(a,b,c,d,e){let f=b||this._wallet,g=c||this._preparedMessage;if(!f)throw Error("A wallet must be provided in the init step or as an argument to loginWithSiwe");if(!g)throw Error("A message must be generated and signed before being used to login to privy with a wallet");let h=await this._privyInternal.fetch(bg,{body:{signature:a,message:g,chainId:f.chainId,walletClientType:f.walletClientType??null,connectorType:f.connectorType??null,mode:d}});await this._privyInternal.session.updateWithTokensResponse(h);let i=await aB(this._embedded,h,e?.embedded);return this._privyInternal.callbacks?.setUser?.(i.user),i}async init(a,b,c){var d;this._wallet=a;let{nonce:e}=await this._privyInternal.fetch(bf,{body:{address:a.address}}),f=`${(d={chainId:a.chainId.toString().replace("eip155:",""),address:a.address,issuedAt:(new Date).toISOString(),statement:"By signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.",domain:b,nonce:e,uri:c}).domain} wants you to sign in with your Ethereum account:
${d.address}

${d.statement}

URI: ${d.uri}
Version: 1
Chain ID: ${d.chainId}
Nonce: ${d.nonce}
Issued At: ${d.issuedAt}
Resources:
- https://privy.io`;return this._preparedMessage=f,{nonce:e,message:f}}constructor(a,b){this._wallet=void 0,this._privyInternal=a,this._embedded=b}}let bl={path:"/api/v1/siws/init",method:"POST"},bm={path:"/api/v1/siws/authenticate",method:"POST"},bn={path:"/api/v1/siws/link",method:"POST"},bo={path:"/api/v1/siws/unlink",method:"POST"};class bp{async unlink({address:a}){await this._privyInternal.fetch(bo,{body:{address:a}});let b=await this._privyInternal.refreshSession();return{user:b.user,identity_token:b.identity_token}}async link({message:a,signature:b,walletClientType:c,connectorType:d}){await this._privyInternal.fetch(bn,{body:{message:a,signature:b,walletClientType:c??null,connectorType:d??null}});let e=await this._privyInternal.refreshSession();return{user:e.user,identity_token:e.identity_token}}async login({mode:a,message:b,signature:c,walletClientType:d,connectorType:e,opts:f}){let g=await this._privyInternal.fetch(bm,{body:{signature:c,message:b,walletClientType:d??null,connectorType:e??null,mode:a}});await this._privyInternal.session.updateWithTokensResponse(g);let h=await aB(this._embedded,g,f?.embedded);return this._privyInternal.callbacks?.setUser?.(h.user),h}async fetchNonce({address:a}){let{nonce:b}=await this._privyInternal.fetch(bl,{body:{address:a}});return{nonce:b}}constructor(a,b){this._privyInternal=a,this._embedded=b}}class bq{async link(a,b,c,d){await this._privyInternal.fetch(bi,{body:{message:a,signature:b,smart_wallet_type:c,smart_wallet_version:d}});let e=await this._privyInternal.refreshSession();return{user:e.user,identity_token:e.identity_token}}async init(a){var b;let{nonce:c}=await this._privyInternal.fetch(bf,{body:{address:a.address}});return{nonce:c,message:`${(b={chainId:a.chainId.toString().replace("eip155:",""),address:a.address,issuedAt:(new Date).toISOString(),statement:"By signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.",domain:"privy.io",uri:"https://auth.privy.io",nonce:c}).domain} wants you to sign in with your Ethereum account:
${b.address}

${b.statement}

URI: ${b.uri}
Version: 1
Chain ID: ${b.chainId}
Nonce: ${b.nonce}
Issued At: ${b.issuedAt}
Resources:
- https://privy.io`}}constructor(a){this._privyInternal=a}}class br{async logout(a){try{let a=await this._privyInternal.session.getRefreshToken()??void 0;await this._privyInternal.fetch(aa,{body:{refresh_token:a}})}catch(a){console.warn("Error destroying session")}await Promise.all([this._privyInternal.session.destroyLocalState({reason:"logout"}),this._privyInternal.destroyClientAnalyticsId(),a?.userId&&this._mfa.clearMfa({userId:a.userId})]),this._privyInternal.callbacks?.setUser?.(null)}constructor(a,b,c,d,e){this._privyInternal=a,this._mfa=e,this.customProvider=new aC(this._privyInternal,b),this.phone=new be(this._privyInternal,b),this.email=new aI(this._privyInternal,b),this.oauth=new a1(this._privyInternal,b,c,d),this.guest=new aT(this._privyInternal,b),this.siwe=new bk(this._privyInternal,b),this.siws=new bp(this._privyInternal,b),this.smartWallet=new bq(this._privyInternal),this.passkey=new a8(this._privyInternal,b),this.farcaster=new aQ(this._privyInternal,b),this.farcasterV2=new aR(this._privyInternal,b)}}let bs={path:"/api/v1/funding/coinbase_on_ramp/init",method:"POST"},bt={path:"/api/v1/funding/coinbase_on_ramp/status",method:"GET"};class bu{async initOnRampSession(a){return await this._privyInternal.fetch(bs,{body:a})}async getStatus(a){return await this._privyInternal.fetch(bt,{query:{partnerUserId:a}})}constructor(a){this._privyInternal=a}}let bv={path:"/api/v1/plugins/moonpay_on_ramp/sign",method:"POST"};var bw=a.i(595018);class bx{async sign(a){return await this._privyInternal.fetch(bv,{body:a})}async getTransactionStatus({transactionId:a,useSandbox:b}){let{url:c,key:d}=bw.MoonpayEnvironments[b?"sandbox":"prod"],e=await (0,O.default)(fetch,{retries:3,retryDelay:500})(`${c}/transactions/ext/${a}?apiKey=${d}`);if(!e.ok)throw new g.MoonpayApiError({error:`Failed to fetch transaction status for Transaction ${a}`,code:"failed_to_fetch_moonpay_transaction_status",response:e});let f=await e.json();return Array.isArray(f)?f.at(0):void 0}constructor(a){this._privyInternal=a}}class by{constructor(a){this.moonpay=new bx(a),this.coinbase=new bu(a)}}let bz={path:"/api/v1/mfa/passkeys/init",method:"POST"};class bA{async generateAuthenticationOptions(a){return await this._privyInternal.fetch(bz,{body:a})}constructor(a){this._privyInternal=a}}let bB={path:"/api/v1/mfa/passwordless_sms/init",method:"POST"};class bC{async sendCode(a){return await this._privyInternal.fetch(bB,{body:a})}constructor(a){this._privyInternal=a}}class bD{setProxy(a){this.proxy=a}async getAccessTokenInternal(){let a=await this.privyInternal.getAccessTokenInternal();if(!a)throw new g.PrivyClientError({error:"Missing access token",code:"attempted_rpc_call_before_logged_in"});return a}async verifyMfa(){if(!this.proxy)throw new g.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_webview_not_loaded"});return await this.proxy.verifyMfa({accessToken:await this.getAccessTokenInternal()})}async initEnrollMfa(a){if(!this.proxy)throw new g.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_webview_not_loaded"});return await this.proxy.initEnrollMfa({...a,accessToken:await this.getAccessTokenInternal()})}async submitEnrollMfa(a){if(!this.proxy)throw new g.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_webview_not_loaded"});let b=await this.proxy.submitEnrollMfa({...a,accessToken:await this.getAccessTokenInternal()});return await this.privyInternal.refreshSession(),b}async unenrollMfa(a){if(!this.proxy)throw new g.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_webview_not_loaded"});let b=await this.proxy.unenrollMfa({method:a,accessToken:await this.getAccessTokenInternal()});return await this.privyInternal.refreshSession(),b}async clearMfa(a){if(!this.proxy)throw new g.PrivyClientError({error:"Embedded wallet proxy not initialized",code:"embedded_wallet_webview_not_loaded"});return await this.proxy.clearMfa(a)}constructor(a,b){this.proxy=b,this.privyInternal=a,this.sms=new bC(a),this.passkey=new bA(a)}}let bE={path:"/api/v1/embedded_wallets/:address/recovery/key_material",method:"POST"},bF={path:"/api/v1/recovery/oauth/init",method:"POST"},bG={path:"/api/v1/recovery/oauth/authenticate",method:"POST"},bH={path:"/api/v1/recovery/oauth/init_icloud",method:"POST"},bI={path:"/api/v1/recovery/configuration_icloud",method:"POST"},bJ=class{async init(a){return this._privyInternal.fetch(bH,{body:{client_type:a}})}async getICloudConfiguration(a){return this._privyInternal.fetch(bI,{body:{client_type:a}})}constructor(a){this._privyInternal=a}};class bK{async generateURL(a){let b=a_(),c=a_(),d=await a0({codeVerifier:b,digest:this._crypto?.digest});return await Promise.all([this._storage.put(aZ,b),this._storage.put(aY,c)]),this._privyInternal.fetch(bF,{body:{redirect_to:a,code_challenge:d,state_code:c}})}async authorize(a,b){let[c,d]=await Promise.all([this._storage.get(aZ),this._storage.get(aY)]);if(d!==b)throw this._privyInternal.createAnalyticsEvent("possible_phishing_attempt",{flow:"recovery_oauth",storedStateCode:d??"",returnedStateCode:b??""}),new g.PrivyClientError({code:"pkce_state_code_mismatch",error:"Unexpected auth flow. This may be a phishing attempt."});let e=await this._privyInternal.fetch(bG,{body:{authorization_code:a,state_code:d,code_verifier:c}});return await Promise.all([this._storage.del(aZ),this._storage.del(aY)]),e}constructor(a,b,c){this._privyInternal=a,this._storage=b,this._crypto=c}}class bL{async getRecoveryKeyMaterial(a,b){return this._privyInternal.fetch(bE,{body:{chain_type:b},params:{address:a}})}constructor(a,b,c){this._privyInternal=a,this.auth=new bK(this._privyInternal,b,c),this.icloudAuth=new bJ(this._privyInternal)}}class bM{async initialize(){await this._privyInternal._initialize()}setMessagePoster(a){this.embeddedWallet.setMessagePoster(a)}addOAuthTokensListener(a){return this._privyInternal.session.on("oauth_tokens_granted",a),{unsubscribe:()=>{this._privyInternal.session.removeListener("oauth_tokens_granted",a)}}}setCallbacks(a){this._privyInternal.setCallbacks(a)}getAccessToken(){return this._privyInternal.getAccessToken()}getIdentityToken(){return this._privyInternal.getIdentityToken()}getCompiledPath(a,b){return this._privyInternal.getPath(a,b)}async fetchPrivyRoute(a,b){return this._privyInternal.fetch(a,b)}get logger(){return this._privyInternal.logger}constructor({clientId:a,...e}){this._privyInternal=new at({...e,appClientId:a}),this.mfa=new bD(this._privyInternal),this.mfaPromises=new N,this.app=new b.default(this._privyInternal),this.embeddedWallet=new L(this._privyInternal,e.embeddedWalletMessagePoster,e.supportedChains,this.mfa,this.mfaPromises,this.app),this.user=new av(this._privyInternal),this.auth=new br(this._privyInternal,this.embeddedWallet,e.storage,e.crypto,this.mfa),this.recovery=new bL(this._privyInternal,e.storage,e.crypto),this.funding=new by(this._privyInternal),this.delegated=new d.default(this._privyInternal),this.crossApp=new c.default(this._privyInternal,e.storage)}}a.s(["default",()=>bM],840741);var bN=a.i(863327),bO=a.i(327199);let bP=()=>{let{walletProxy:a,client:b}=(0,bO.u)();return(0,bN.useMemo)(()=>({signWithUserSigner:async({message:c,targetAppId:d})=>{if(!a)throw Error("Wallet proxy not initialized");let e=await b.getAccessToken();if(!e)throw Error("User must be authenticated");let{signature:f}=await a.signWithUserSigner({accessToken:e,message:c,targetAppId:d});return{signature:f}}}),[a,b])};a.s(["u",()=>bP],602275)}];

//# sourceMappingURL=cb648_67969e03._.js.map