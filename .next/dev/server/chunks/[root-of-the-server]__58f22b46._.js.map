{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/jhinresh/Desktop/pincher/lib/server-wallet.ts"],"sourcesContent":["import { createWalletClient, createPublicClient, http } from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { baseSepolia } from \"viem/chains\";\n\n// Reuse the Faucet Key for the Agent (or a dedicated AGENT_PRIVATE_KEY)\nconst PRIVATE_KEY = process.env.FAUCET_PRIVATE_KEY as `0x${string}`;\n\nif (!PRIVATE_KEY) {\n  console.warn(\"⚠️ AGENT WARNING: FAUCET_PRIVATE_KEY is missing. Agent wallet will fail.\");\n}\n\n// 1. Account Setup\nlet account = null;\ntry {\n  let key = process.env.FAUCET_PRIVATE_KEY;\n  console.log(\"Debug: FAUCET_PRIVATE_KEY length:\", key ? key.length : \"undefined\");\n\n  // Auto-fix: Prepend 0x if missing\n  if (key && !key.startsWith(\"0x\")) {\n    console.log(\"⚠️ Auto-fixing key: Prepending '0x'\");\n    key = `0x${key}`;\n  }\n\n  if (key && key.startsWith(\"0x\")) {\n    account = privateKeyToAccount(key as `0x${string}`);\n  } else {\n    console.warn(\"❌ Key missing or invalid format (must start with 0x)\");\n  }\n} catch (e) {\n  console.error(\"❌ Agent Wallet Error: Invalid Private Key format. Check .env.local\");\n}\nexport const agentAccount = account;\n\n// 2. Public Client (Read Blockchain)\nexport const publicClient = createPublicClient({\n  chain: baseSepolia,\n  transport: http(),\n});\n\n// 3. Wallet Client (Write/Sign Transactions)\nexport const agentWallet = agentAccount\n  ? createWalletClient({\n      account: agentAccount!,\n      chain: baseSepolia,\n      transport: http(),\n    })\n  : (null as any);\n\n// Helper: Check Agent Balance\n/**\n *\n */\nexport async function getAgentBalance() {\n  if (!agentAccount) return \"0\";\n  const balance = await publicClient.getBalance({ address: agentAccount.address });\n  // Return formatted string if needed, or keeping explicit bigint elsewhere\n  return balance;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AACA;AACA;;;;AAEA,wEAAwE;AACxE,MAAM,cAAc,QAAQ,GAAG,CAAC,kBAAkB;AAElD,IAAI,CAAC,aAAa;IAChB,QAAQ,IAAI,CAAC;AACf;AAEA,mBAAmB;AACnB,IAAI,UAAU;AACd,IAAI;IACF,IAAI,MAAM,QAAQ,GAAG,CAAC,kBAAkB;IACxC,QAAQ,GAAG,CAAC,qCAAqC,MAAM,IAAI,MAAM,GAAG;IAEpE,kCAAkC;IAClC,IAAI,OAAO,CAAC,IAAI,UAAU,CAAC,OAAO;QAChC,QAAQ,GAAG,CAAC;QACZ,MAAM,CAAC,EAAE,EAAE,KAAK;IAClB;IAEA,IAAI,OAAO,IAAI,UAAU,CAAC,OAAO;QAC/B,UAAU,IAAA,8MAAmB,EAAC;IAChC,OAAO;QACL,QAAQ,IAAI,CAAC;IACf;AACF,EAAE,OAAO,GAAG;IACV,QAAQ,KAAK,CAAC;AAChB;AACO,MAAM,eAAe;AAGrB,MAAM,eAAe,IAAA,2MAAkB,EAAC;IAC7C,OAAO,2MAAW;IAClB,WAAW,IAAA,6LAAI;AACjB;AAGO,MAAM,cAAc,eACvB,IAAA,2MAAkB,EAAC;IACjB,SAAS;IACT,OAAO,2MAAW;IAClB,WAAW,IAAA,6LAAI;AACjB,KACC;AAME,eAAe;IACpB,IAAI,CAAC,cAAc,OAAO;IAC1B,MAAM,UAAU,MAAM,aAAa,UAAU,CAAC;QAAE,SAAS,aAAa,OAAO;IAAC;IAC9E,0EAA0E;IAC1E,OAAO;AACT"}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///Users/jhinresh/Desktop/pincher/app/api/escrow/deposit/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { createClient } from \"@supabase/supabase-js\";\nimport { publicClient, agentAccount } from \"@/lib/server-wallet\";\n\n/**\n *\n * @param req\n */\nexport async function POST(req: Request) {\n  try {\n    const { rideId, txHash, userAddress } = await req.json();\n\n    if (!rideId || !txHash) {\n      return NextResponse.json({ error: \"Missing rideId or txHash\" }, { status: 400 });\n    }\n\n    // 1. Verify Transaction on Blockchain\n    console.log(`[Escrow] Verifying tx: ${txHash}...`);\n    const receipt = await publicClient.getTransactionReceipt({ hash: txHash as `0x${string}` });\n\n    if (receipt.status !== \"success\") {\n      return NextResponse.json({ error: \"Transaction failed on-chain\" }, { status: 400 });\n    }\n\n    // (Optional) Verify receiver is Agent\n    // This is a basic check. In production, parsing logs for strict ERC20 transfer is better.\n    // For native ETH: receipt.to === agentAccount.address\n    // For USDC: we check logs, but for hackathon, success + user claim is \"good enough\" trust level.\n    // We will trust the success for now to keep it simpler.\n\n    // 2. Update Ride Status in DB\n    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\n    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\n    const supabase = createClient(supabaseUrl, supabaseKey);\n\n    const { error } = await supabase\n      .from(\"rides\")\n      .update({ status: \"escrow_holding\" }) // Custom status indicating funds are locked\n      .eq(\"id\", rideId);\n\n    if (error) {\n      console.error(\"Supabase Error\", error);\n      return NextResponse.json({ error: \"DB Update Failed\" }, { status: 500 });\n    }\n\n    // 3. Instant V2 Minting (Airdrop to User)\n    try {\n      if (!process.env.FAUCET_PRIVATE_KEY) throw new Error(\"Agent Key Missing\");\n\n      // Dynamic Import to avoid build issues if file structure varies, or just re-import\n      const { agentWallet } = await import(\"@/lib/server-wallet\");\n\n      console.log(`[V2] Minting Ticket #${rideId} to ${userAddress}...`);\n\n      const hash = await agentWallet.writeContract({\n        address: \"0x1225A84FC29FcdA297736ffe22977f8C594C21bc\",\n        abi: [\n          {\n            name: \"adminMint\",\n            type: \"function\",\n            stateMutability: \"nonpayable\",\n            inputs: [\n              { name: \"to\", type: \"address\" },\n              { name: \"rideId\", type: \"uint256\" },\n            ],\n            outputs: [],\n          },\n        ],\n        functionName: \"adminMint\",\n        args: [userAddress, BigInt(rideId)],\n      });\n      console.log(`[V2] Minted! Tx: ${hash}`);\n    } catch (mintError) {\n      console.error(\"[V2] Minting Failed (Non-blocking):\", mintError);\n    }\n\n    console.log(`[Escrow] Ride ${rideId} locked. Funds in Agent Wallet.`);\n    return NextResponse.json({ success: true, status: \"escrow_holding\" });\n  } catch (error: any) {\n    console.error(\"Deposit Error:\", error);\n    return NextResponse.json({ error: error.message || \"Internal Error\" }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAMO,eAAe,KAAK,GAAY;IACrC,IAAI;QACF,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,GAAG,MAAM,IAAI,IAAI;QAEtD,IAAI,CAAC,UAAU,CAAC,QAAQ;YACtB,OAAO,sKAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA2B,GAAG;gBAAE,QAAQ;YAAI;QAChF;QAEA,sCAAsC;QACtC,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,OAAO,GAAG,CAAC;QACjD,MAAM,UAAU,MAAM,+JAAY,CAAC,qBAAqB,CAAC;YAAE,MAAM;QAAwB;QAEzF,IAAI,QAAQ,MAAM,KAAK,WAAW;YAChC,OAAO,sKAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA8B,GAAG;gBAAE,QAAQ;YAAI;QACnF;QAEA,sCAAsC;QACtC,0FAA0F;QAC1F,sDAAsD;QACtD,iGAAiG;QACjG,wDAAwD;QAExD,8BAA8B;QAC9B,MAAM;QACN,MAAM;QACN,MAAM,WAAW,IAAA,sNAAY,EAAC,aAAa;QAE3C,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,SACrB,IAAI,CAAC,SACL,MAAM,CAAC;YAAE,QAAQ;QAAiB,GAAG,4CAA4C;SACjF,EAAE,CAAC,MAAM;QAEZ,IAAI,OAAO;YACT,QAAQ,KAAK,CAAC,kBAAkB;YAChC,OAAO,sKAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAmB,GAAG;gBAAE,QAAQ;YAAI;QACxE;QAEA,0CAA0C;QAC1C,IAAI;YACF,IAAI,CAAC,QAAQ,GAAG,CAAC,kBAAkB,EAAE,MAAM,IAAI,MAAM;YAErD,mFAAmF;YACnF,MAAM,EAAE,WAAW,EAAE,GAAG;YAExB,QAAQ,GAAG,CAAC,CAAC,qBAAqB,EAAE,OAAO,IAAI,EAAE,YAAY,GAAG,CAAC;YAEjE,MAAM,OAAO,MAAM,YAAY,aAAa,CAAC;gBAC3C,SAAS;gBACT,KAAK;oBACH;wBACE,MAAM;wBACN,MAAM;wBACN,iBAAiB;wBACjB,QAAQ;4BACN;gCAAE,MAAM;gCAAM,MAAM;4BAAU;4BAC9B;gCAAE,MAAM;gCAAU,MAAM;4BAAU;yBACnC;wBACD,SAAS,EAAE;oBACb;iBACD;gBACD,cAAc;gBACd,MAAM;oBAAC;oBAAa,OAAO;iBAAQ;YACrC;YACA,QAAQ,GAAG,CAAC,CAAC,iBAAiB,EAAE,MAAM;QACxC,EAAE,OAAO,WAAW;YAClB,QAAQ,KAAK,CAAC,uCAAuC;QACvD;QAEA,QAAQ,GAAG,CAAC,CAAC,cAAc,EAAE,OAAO,+BAA+B,CAAC;QACpE,OAAO,sKAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAM,QAAQ;QAAiB;IACrE,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,kBAAkB;QAChC,OAAO,sKAAY,CAAC,IAAI,CAAC;YAAE,OAAO,MAAM,OAAO,IAAI;QAAiB,GAAG;YAAE,QAAQ;QAAI;IACvF;AACF"}}]
}