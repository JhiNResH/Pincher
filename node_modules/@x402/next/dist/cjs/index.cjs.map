{"version":3,"sources":["../../src/index.ts","../../src/utils.ts","../../src/adapter.ts"],"sourcesContent":["import {\n  PaywallConfig,\n  PaywallProvider,\n  x402ResourceServer,\n  RoutesConfig,\n  RouteConfig,\n  FacilitatorClient,\n} from \"@x402/core/server\";\nimport { SchemeNetworkServer, Network } from \"@x402/core/types\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport {\n  createHttpServer,\n  createRequestContext,\n  handlePaymentError,\n  handleSettlement,\n} from \"./utils\";\n\n/**\n * Configuration for registering a payment scheme with a specific network\n */\nexport interface SchemeRegistration {\n  /**\n   * The network identifier (e.g., 'eip155:84532', 'solana:mainnet')\n   */\n  network: Network;\n\n  /**\n   * The scheme server implementation for this network\n   */\n  server: SchemeNetworkServer;\n}\n\n/**\n * Next.js payment proxy for x402 protocol (direct server instance).\n *\n * Use this when you want to pass a pre-configured x402ResourceServer instance.\n * This provides more flexibility for testing, custom configuration, and reusing\n * server instances across multiple proxies.\n *\n * @param routes - Route configurations for protected endpoints\n * @param server - Pre-configured x402ResourceServer instance\n * @param paywallConfig - Optional configuration for the built-in paywall UI\n * @param paywall - Optional custom paywall provider (overrides default)\n * @param syncFacilitatorOnStart - Whether to sync with the facilitator on startup (defaults to true)\n * @returns Next.js proxy handler\n *\n * @example\n * ```typescript\n * import { paymentProxy } from \"@x402/next\";\n * import { x402ResourceServer } from \"@x402/core/server\";\n * import { registerExactEvmScheme } from \"@x402/evm/exact/server\";\n *\n * const server = new x402ResourceServer(myFacilitatorClient);\n * registerExactEvmScheme(server, {});\n *\n * export const proxy = paymentProxy(routes, server, paywallConfig);\n * ```\n */\nexport function paymentProxy(\n  routes: RoutesConfig,\n  server: x402ResourceServer,\n  paywallConfig?: PaywallConfig,\n  paywall?: PaywallProvider,\n  syncFacilitatorOnStart: boolean = true,\n) {\n  const { httpServer, init } = createHttpServer(routes, server, paywall, syncFacilitatorOnStart);\n\n  // Dynamically register bazaar extension if routes declare it\n  let bazaarPromise: Promise<void> | null = null;\n  if (checkIfBazaarNeeded(routes)) {\n    bazaarPromise = import(/* webpackIgnore: true */ \"@x402/extensions/bazaar\")\n      .then(({ bazaarResourceServerExtension }) => {\n        server.registerExtension(bazaarResourceServerExtension);\n      })\n      .catch(err => {\n        console.error(\"Failed to load bazaar extension:\", err);\n      });\n  }\n\n  return async (req: NextRequest) => {\n    const context = createRequestContext(req);\n\n    // Check if route requires payment before initializing facilitator\n    if (!httpServer.requiresPayment(context)) {\n      return NextResponse.next();\n    }\n\n    // Only initialize when processing a protected route\n    await init();\n\n    // Await bazaar extension loading if needed\n    if (bazaarPromise) {\n      await bazaarPromise;\n      bazaarPromise = null;\n    }\n\n    // Process payment requirement check\n    const result = await httpServer.processHTTPRequest(context, paywallConfig);\n\n    // Handle the different result types\n    switch (result.type) {\n      case \"no-payment-required\":\n        // No payment needed, proceed directly to the route handler\n        return NextResponse.next();\n\n      case \"payment-error\":\n        return handlePaymentError(result.response);\n\n      case \"payment-verified\": {\n        // Payment is valid, need to wrap response for settlement\n        const { paymentPayload, paymentRequirements } = result;\n\n        // Proceed to the next proxy or route handler\n        const nextResponse = NextResponse.next();\n        return handleSettlement(httpServer, nextResponse, paymentPayload, paymentRequirements);\n      }\n    }\n  };\n}\n\n/**\n * Next.js payment proxy for x402 protocol (configuration-based).\n *\n * Use this when you want to quickly set up proxy with simple configuration.\n * This function creates and configures the x402ResourceServer internally.\n *\n * @param routes - Route configurations for protected endpoints\n * @param facilitatorClients - Optional facilitator client(s) for payment processing\n * @param schemes - Optional array of scheme registrations for server-side payment processing\n * @param paywallConfig - Optional configuration for the built-in paywall UI\n * @param paywall - Optional custom paywall provider (overrides default)\n * @param syncFacilitatorOnStart - Whether to sync with the facilitator on startup (defaults to true)\n * @returns Next.js proxy handler\n *\n * @example\n * ```typescript\n * import { paymentProxyFromConfig } from \"@x402/next\";\n *\n * export const proxy = paymentProxyFromConfig(\n *   routes,\n *   myFacilitatorClient,\n *   [{ network: \"eip155:8453\", server: evmSchemeServer }],\n *   paywallConfig\n * );\n * ```\n */\nexport function paymentProxyFromConfig(\n  routes: RoutesConfig,\n  facilitatorClients?: FacilitatorClient | FacilitatorClient[],\n  schemes?: SchemeRegistration[],\n  paywallConfig?: PaywallConfig,\n  paywall?: PaywallProvider,\n  syncFacilitatorOnStart: boolean = true,\n) {\n  const ResourceServer = new x402ResourceServer(facilitatorClients);\n\n  if (schemes) {\n    schemes.forEach(({ network, server: schemeServer }) => {\n      ResourceServer.register(network, schemeServer);\n    });\n  }\n\n  // Use the direct paymentProxy with the configured server\n  // Note: paymentProxy handles dynamic bazaar registration\n  return paymentProxy(routes, ResourceServer, paywallConfig, paywall, syncFacilitatorOnStart);\n}\n\n/**\n * Wraps a Next.js App Router API route handler with x402 payment protection.\n *\n * Unlike `paymentProxy` which works as middleware, `withX402` wraps individual route handlers\n * and guarantees that payment settlement only occurs after the handler returns a successful\n * response (status < 400). This provides more precise control over when payments are settled.\n *\n * @param routeHandler - The API route handler function to wrap\n * @param routeConfig - Payment configuration for this specific route\n * @param server - Pre-configured x402ResourceServer instance\n * @param paywallConfig - Optional configuration for the built-in paywall UI\n * @param paywall - Optional custom paywall provider (overrides default)\n * @param syncFacilitatorOnStart - Whether to sync with the facilitator on startup (defaults to true)\n * @returns A wrapped Next.js route handler\n *\n * @example\n * ```typescript\n * import { NextRequest, NextResponse } from \"next/server\";\n * import { withX402 } from \"@x402/next\";\n * import { x402ResourceServer } from \"@x402/core/server\";\n * import { registerExactEvmScheme } from \"@x402/evm/exact/server\";\n *\n * const server = new x402ResourceServer(myFacilitatorClient);\n * registerExactEvmScheme(server, {});\n *\n * const handler = async (request: NextRequest) => {\n *   return NextResponse.json({ data: \"protected content\" });\n * };\n *\n * export const GET = withX402(\n *   handler,\n *   {\n *     accepts: {\n *       scheme: \"exact\",\n *       payTo: \"0x123...\",\n *       price: \"$0.01\",\n *       network: \"eip155:84532\",\n *     },\n *     description: \"Access to protected API\",\n *   },\n *   server,\n * );\n * ```\n */\nexport function withX402<T = unknown>(\n  routeHandler: (request: NextRequest) => Promise<NextResponse<T>>,\n  routeConfig: RouteConfig,\n  server: x402ResourceServer,\n  paywallConfig?: PaywallConfig,\n  paywall?: PaywallProvider,\n  syncFacilitatorOnStart: boolean = true,\n): (request: NextRequest) => Promise<NextResponse<T>> {\n  const routes = { \"*\": routeConfig };\n  const { httpServer, init } = createHttpServer(routes, server, paywall, syncFacilitatorOnStart);\n\n  // Dynamically register bazaar extension if route declares it\n  let bazaarPromise: Promise<void> | null = null;\n  if (checkIfBazaarNeeded(routes)) {\n    bazaarPromise = import(/* webpackIgnore: true */ \"@x402/extensions/bazaar\")\n      .then(({ bazaarResourceServerExtension }) => {\n        server.registerExtension(bazaarResourceServerExtension);\n      })\n      .catch(err => {\n        console.error(\"Failed to load bazaar extension:\", err);\n      });\n  }\n\n  return async (request: NextRequest): Promise<NextResponse<T>> => {\n    await init();\n\n    // Await bazaar extension loading if needed\n    if (bazaarPromise) {\n      await bazaarPromise;\n      bazaarPromise = null;\n    }\n\n    const context = createRequestContext(request);\n\n    // Process payment requirement check\n    const result = await httpServer.processHTTPRequest(context, paywallConfig);\n\n    // Handle the different result types\n    switch (result.type) {\n      case \"no-payment-required\":\n        // No payment needed, proceed directly to the route handler\n        return routeHandler(request);\n\n      case \"payment-error\":\n        return handlePaymentError(result.response) as NextResponse<T>;\n\n      case \"payment-verified\": {\n        // Payment is valid, need to wrap response for settlement\n        const { paymentPayload, paymentRequirements } = result;\n        const handlerResponse = await routeHandler(request);\n        return handleSettlement(\n          httpServer,\n          handlerResponse,\n          paymentPayload,\n          paymentRequirements,\n        ) as Promise<NextResponse<T>>;\n      }\n    }\n  };\n}\n\n/**\n * Check if any routes in the configuration declare bazaar extensions\n *\n * @param routes - Route configuration\n * @returns True if any route has extensions.bazaar defined\n */\nfunction checkIfBazaarNeeded(routes: RoutesConfig): boolean {\n  // Handle single route config\n  if (\"accepts\" in routes) {\n    return !!(routes.extensions && \"bazaar\" in routes.extensions);\n  }\n\n  // Handle multiple routes\n  return Object.values(routes).some(routeConfig => {\n    return !!(routeConfig.extensions && \"bazaar\" in routeConfig.extensions);\n  });\n}\n\nexport type {\n  PaymentRequired,\n  PaymentRequirements,\n  PaymentPayload,\n  Network,\n  SchemeNetworkServer,\n} from \"@x402/core/types\";\n\nexport type { PaywallProvider, PaywallConfig, RouteConfig } from \"@x402/core/server\";\n\nexport { RouteConfigurationError } from \"@x402/core/server\";\n\nexport type { RouteValidationError } from \"@x402/core/server\";\n\nexport { NextAdapter } from \"./adapter\";\n","import { NextRequest, NextResponse } from \"next/server\";\nimport {\n  HTTPRequestContext,\n  HTTPResponseInstructions,\n  PaywallProvider,\n  x402HTTPResourceServer,\n  x402ResourceServer,\n  RoutesConfig,\n} from \"@x402/core/server\";\nimport { PaymentPayload, PaymentRequirements } from \"@x402/core/types\";\nimport { NextAdapter } from \"./adapter\";\n\n/**\n * Result of createHttpServer\n */\nexport interface HttpServerInstance {\n  httpServer: x402HTTPResourceServer;\n  init: () => Promise<void>;\n}\n\n/**\n * Creates and configures the x402 HTTP server with initialization logic\n *\n * @param routes - The route configuration for the server\n * @param server - The x402 resource server instance\n * @param paywall - Optional paywall provider for custom payment UI\n * @param syncFacilitatorOnStart - Whether to sync with the facilitator on start (defaults to true)\n * @returns The HTTP server instance with initialization function\n */\nexport function createHttpServer(\n  routes: RoutesConfig,\n  server: x402ResourceServer,\n  paywall?: PaywallProvider,\n  syncFacilitatorOnStart: boolean = true,\n): HttpServerInstance {\n  // Create the x402 HTTP server instance with the resource server\n  const httpServer = new x402HTTPResourceServer(server, routes);\n\n  // Register custom paywall provider if provided\n  if (paywall) {\n    httpServer.registerPaywallProvider(paywall);\n  }\n\n  // Store initialization promise (not the result)\n  // httpServer.initialize() fetches facilitator support and validates routes\n  let initPromise: Promise<void> | null = syncFacilitatorOnStart ? httpServer.initialize() : null;\n\n  return {\n    httpServer,\n    async init() {\n      // Ensure initialization completes before processing\n      if (initPromise) {\n        await initPromise;\n        initPromise = null; // Clear after first await\n      }\n    },\n  };\n}\n\n/**\n * Creates HTTP request context from a Next.js request\n *\n * @param request - The Next.js request object\n * @returns The HTTP request context for x402 processing\n */\nexport function createRequestContext(request: NextRequest): HTTPRequestContext {\n  // Create adapter and context\n  const adapter = new NextAdapter(request);\n  return {\n    adapter,\n    path: request.nextUrl.pathname,\n    method: request.method,\n    paymentHeader: adapter.getHeader(\"payment-signature\") || adapter.getHeader(\"x-payment\"),\n  };\n}\n\n/**\n * Handles payment error result by creating a 402 response\n *\n * @param response - The HTTP response instructions from payment verification\n * @returns A Next.js response with the appropriate 402 status and headers\n */\nexport function handlePaymentError(response: HTTPResponseInstructions): NextResponse {\n  // Payment required but not provided or invalid\n  const headers = new Headers(response.headers);\n  if (response.isHtml) {\n    headers.set(\"Content-Type\", \"text/html\");\n    return new NextResponse(response.body as string, {\n      status: response.status,\n      headers,\n    });\n  }\n  headers.set(\"Content-Type\", \"application/json\");\n  return new NextResponse(JSON.stringify(response.body || {}), {\n    status: response.status,\n    headers,\n  });\n}\n\n/**\n * Handles settlement after a successful response\n *\n * @param httpServer - The x402 HTTP resource server instance\n * @param response - The Next.js response from the protected route\n * @param paymentPayload - The payment payload from the client\n * @param paymentRequirements - The payment requirements for the route\n * @returns The response with settlement headers or an error response if settlement fails\n */\nexport async function handleSettlement(\n  httpServer: x402HTTPResourceServer,\n  response: NextResponse,\n  paymentPayload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): Promise<NextResponse> {\n  // If the response from the protected route is >= 400, do not settle payment\n  if (response.status >= 400) {\n    return response;\n  }\n\n  try {\n    const result = await httpServer.processSettlement(paymentPayload, paymentRequirements);\n\n    if (!result.success) {\n      // Settlement failed - do not return the protected resource\n      return new NextResponse(\n        JSON.stringify({\n          error: \"Settlement failed\",\n          details: result.errorReason,\n        }),\n        {\n          status: 402,\n          headers: { \"Content-Type\": \"application/json\" },\n        },\n      );\n    }\n\n    // Settlement succeeded - add headers and return original response\n    Object.entries(result.headers).forEach(([key, value]) => {\n      response.headers.set(key, value);\n    });\n\n    return response;\n  } catch (error) {\n    console.error(\"Settlement failed:\", error);\n    // If settlement fails, return an error response\n    return new NextResponse(\n      JSON.stringify({\n        error: \"Settlement failed\",\n        details: error instanceof Error ? error.message : \"Unknown error\",\n      }),\n      {\n        status: 402,\n        headers: { \"Content-Type\": \"application/json\" },\n      },\n    );\n  }\n}\n","import { HTTPAdapter } from \"@x402/core/server\";\nimport { NextRequest } from \"next/server\";\n\n/**\n * Next.js adapter implementation\n */\nexport class NextAdapter implements HTTPAdapter {\n  /**\n   * Creates a new NextAdapter instance.\n   *\n   * @param req - The Next.js request object\n   */\n  constructor(private req: NextRequest) {}\n\n  /**\n   * Gets a header value from the request.\n   *\n   * @param name - The header name\n   * @returns The header value or undefined\n   */\n  getHeader(name: string): string | undefined {\n    return this.req.headers.get(name) || undefined;\n  }\n\n  /**\n   * Gets the HTTP method of the request.\n   *\n   * @returns The HTTP method\n   */\n  getMethod(): string {\n    return this.req.method;\n  }\n\n  /**\n   * Gets the path of the request.\n   *\n   * @returns The request path\n   */\n  getPath(): string {\n    return this.req.nextUrl.pathname;\n  }\n\n  /**\n   * Gets the full URL of the request.\n   *\n   * @returns The full request URL\n   */\n  getUrl(): string {\n    return this.req.url;\n  }\n\n  /**\n   * Gets the Accept header from the request.\n   *\n   * @returns The Accept header value or empty string\n   */\n  getAcceptHeader(): string {\n    return this.req.headers.get(\"Accept\") || \"\";\n  }\n\n  /**\n   * Gets the User-Agent header from the request.\n   *\n   * @returns The User-Agent header value or empty string\n   */\n  getUserAgent(): string {\n    return this.req.headers.get(\"User-Agent\") || \"\";\n  }\n\n  /**\n   * Gets all query parameters from the request URL.\n   *\n   * @returns Record of query parameter key-value pairs\n   */\n  getQueryParams(): Record<string, string | string[]> {\n    const params: Record<string, string | string[]> = {};\n    this.req.nextUrl.searchParams.forEach((value, key) => {\n      const existing = params[key];\n      if (existing) {\n        if (Array.isArray(existing)) {\n          existing.push(value);\n        } else {\n          params[key] = [existing, value];\n        }\n      } else {\n        params[key] = value;\n      }\n    });\n    return params;\n  }\n\n  /**\n   * Gets a specific query parameter by name.\n   *\n   * @param name - The query parameter name\n   * @returns The query parameter value(s) or undefined\n   */\n  getQueryParam(name: string): string | string[] | undefined {\n    const all = this.req.nextUrl.searchParams.getAll(name);\n    if (all.length === 0) return undefined;\n    if (all.length === 1) return all[0];\n    return all;\n  }\n\n  /**\n   * Gets the parsed request body.\n   *\n   * @returns Promise resolving to the parsed request body\n   */\n  async getBody(): Promise<unknown> {\n    try {\n      return await this.req.json();\n    } catch {\n      return undefined;\n    }\n  }\n}\n"],"mappings":"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","names":["import_server","import_server","import_server"]}