"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  NextAdapter: () => NextAdapter,
  RouteConfigurationError: () => import_server5.RouteConfigurationError,
  paymentProxy: () => paymentProxy,
  paymentProxyFromConfig: () => paymentProxyFromConfig,
  withX402: () => withX402
});
module.exports = __toCommonJS(src_exports);
var import_server3 = require("@x402/core/server");
var import_server4 = require("next/server");

// src/utils.ts
var import_server = require("next/server");
var import_server2 = require("@x402/core/server");

// src/adapter.ts
var NextAdapter = class {
  /**
   * Creates a new NextAdapter instance.
   *
   * @param req - The Next.js request object
   */
  constructor(req) {
    this.req = req;
  }
  /**
   * Gets a header value from the request.
   *
   * @param name - The header name
   * @returns The header value or undefined
   */
  getHeader(name) {
    return this.req.headers.get(name) || void 0;
  }
  /**
   * Gets the HTTP method of the request.
   *
   * @returns The HTTP method
   */
  getMethod() {
    return this.req.method;
  }
  /**
   * Gets the path of the request.
   *
   * @returns The request path
   */
  getPath() {
    return this.req.nextUrl.pathname;
  }
  /**
   * Gets the full URL of the request.
   *
   * @returns The full request URL
   */
  getUrl() {
    return this.req.url;
  }
  /**
   * Gets the Accept header from the request.
   *
   * @returns The Accept header value or empty string
   */
  getAcceptHeader() {
    return this.req.headers.get("Accept") || "";
  }
  /**
   * Gets the User-Agent header from the request.
   *
   * @returns The User-Agent header value or empty string
   */
  getUserAgent() {
    return this.req.headers.get("User-Agent") || "";
  }
  /**
   * Gets all query parameters from the request URL.
   *
   * @returns Record of query parameter key-value pairs
   */
  getQueryParams() {
    const params = {};
    this.req.nextUrl.searchParams.forEach((value, key) => {
      const existing = params[key];
      if (existing) {
        if (Array.isArray(existing)) {
          existing.push(value);
        } else {
          params[key] = [existing, value];
        }
      } else {
        params[key] = value;
      }
    });
    return params;
  }
  /**
   * Gets a specific query parameter by name.
   *
   * @param name - The query parameter name
   * @returns The query parameter value(s) or undefined
   */
  getQueryParam(name) {
    const all = this.req.nextUrl.searchParams.getAll(name);
    if (all.length === 0) return void 0;
    if (all.length === 1) return all[0];
    return all;
  }
  /**
   * Gets the parsed request body.
   *
   * @returns Promise resolving to the parsed request body
   */
  async getBody() {
    try {
      return await this.req.json();
    } catch {
      return void 0;
    }
  }
};

// src/utils.ts
function createHttpServer(routes, server, paywall, syncFacilitatorOnStart = true) {
  const httpServer = new import_server2.x402HTTPResourceServer(server, routes);
  if (paywall) {
    httpServer.registerPaywallProvider(paywall);
  }
  let initPromise = syncFacilitatorOnStart ? httpServer.initialize() : null;
  return {
    httpServer,
    async init() {
      if (initPromise) {
        await initPromise;
        initPromise = null;
      }
    }
  };
}
function createRequestContext(request) {
  const adapter = new NextAdapter(request);
  return {
    adapter,
    path: request.nextUrl.pathname,
    method: request.method,
    paymentHeader: adapter.getHeader("payment-signature") || adapter.getHeader("x-payment")
  };
}
function handlePaymentError(response) {
  const headers = new Headers(response.headers);
  if (response.isHtml) {
    headers.set("Content-Type", "text/html");
    return new import_server.NextResponse(response.body, {
      status: response.status,
      headers
    });
  }
  headers.set("Content-Type", "application/json");
  return new import_server.NextResponse(JSON.stringify(response.body || {}), {
    status: response.status,
    headers
  });
}
async function handleSettlement(httpServer, response, paymentPayload, paymentRequirements) {
  if (response.status >= 400) {
    return response;
  }
  try {
    const result = await httpServer.processSettlement(paymentPayload, paymentRequirements);
    if (!result.success) {
      return new import_server.NextResponse(
        JSON.stringify({
          error: "Settlement failed",
          details: result.errorReason
        }),
        {
          status: 402,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    Object.entries(result.headers).forEach(([key, value]) => {
      response.headers.set(key, value);
    });
    return response;
  } catch (error) {
    console.error("Settlement failed:", error);
    return new import_server.NextResponse(
      JSON.stringify({
        error: "Settlement failed",
        details: error instanceof Error ? error.message : "Unknown error"
      }),
      {
        status: 402,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}

// src/index.ts
var import_server5 = require("@x402/core/server");
function paymentProxy(routes, server, paywallConfig, paywall, syncFacilitatorOnStart = true) {
  const { httpServer, init } = createHttpServer(routes, server, paywall, syncFacilitatorOnStart);
  let bazaarPromise = null;
  if (checkIfBazaarNeeded(routes)) {
    bazaarPromise = import(
      /* webpackIgnore: true */
      "@x402/extensions/bazaar"
    ).then(({ bazaarResourceServerExtension }) => {
      server.registerExtension(bazaarResourceServerExtension);
    }).catch((err) => {
      console.error("Failed to load bazaar extension:", err);
    });
  }
  return async (req) => {
    const context = createRequestContext(req);
    if (!httpServer.requiresPayment(context)) {
      return import_server4.NextResponse.next();
    }
    await init();
    if (bazaarPromise) {
      await bazaarPromise;
      bazaarPromise = null;
    }
    const result = await httpServer.processHTTPRequest(context, paywallConfig);
    switch (result.type) {
      case "no-payment-required":
        return import_server4.NextResponse.next();
      case "payment-error":
        return handlePaymentError(result.response);
      case "payment-verified": {
        const { paymentPayload, paymentRequirements } = result;
        const nextResponse = import_server4.NextResponse.next();
        return handleSettlement(httpServer, nextResponse, paymentPayload, paymentRequirements);
      }
    }
  };
}
function paymentProxyFromConfig(routes, facilitatorClients, schemes, paywallConfig, paywall, syncFacilitatorOnStart = true) {
  const ResourceServer = new import_server3.x402ResourceServer(facilitatorClients);
  if (schemes) {
    schemes.forEach(({ network, server: schemeServer }) => {
      ResourceServer.register(network, schemeServer);
    });
  }
  return paymentProxy(routes, ResourceServer, paywallConfig, paywall, syncFacilitatorOnStart);
}
function withX402(routeHandler, routeConfig, server, paywallConfig, paywall, syncFacilitatorOnStart = true) {
  const routes = { "*": routeConfig };
  const { httpServer, init } = createHttpServer(routes, server, paywall, syncFacilitatorOnStart);
  let bazaarPromise = null;
  if (checkIfBazaarNeeded(routes)) {
    bazaarPromise = import(
      /* webpackIgnore: true */
      "@x402/extensions/bazaar"
    ).then(({ bazaarResourceServerExtension }) => {
      server.registerExtension(bazaarResourceServerExtension);
    }).catch((err) => {
      console.error("Failed to load bazaar extension:", err);
    });
  }
  return async (request) => {
    await init();
    if (bazaarPromise) {
      await bazaarPromise;
      bazaarPromise = null;
    }
    const context = createRequestContext(request);
    const result = await httpServer.processHTTPRequest(context, paywallConfig);
    switch (result.type) {
      case "no-payment-required":
        return routeHandler(request);
      case "payment-error":
        return handlePaymentError(result.response);
      case "payment-verified": {
        const { paymentPayload, paymentRequirements } = result;
        const handlerResponse = await routeHandler(request);
        return handleSettlement(
          httpServer,
          handlerResponse,
          paymentPayload,
          paymentRequirements
        );
      }
    }
  };
}
function checkIfBazaarNeeded(routes) {
  if ("accepts" in routes) {
    return !!(routes.extensions && "bazaar" in routes.extensions);
  }
  return Object.values(routes).some((routeConfig) => {
    return !!(routeConfig.extensions && "bazaar" in routeConfig.extensions);
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  NextAdapter,
  RouteConfigurationError,
  paymentProxy,
  paymentProxyFromConfig,
  withX402
});
//# sourceMappingURL=index.cjs.map